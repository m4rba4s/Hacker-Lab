<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hacker Lab: Assembly & Reverse Engineering</title>
    <link rel="stylesheet" href="assets/css/hacker_lab.css">
</head>
<body>
    <div id="app">
        <header id="topbar">
üöÄL0W-L3V3L Lab - Assembly & Reverse Engineering
<span id="progress-span" style="margin-left:12px;color:var(--muted);font-size:12px;"></span>
<button id="open-qoder" class="btn mini" style="margin-left:auto">ü§ñ Qoder</button>
</header>
        
        <main id="workspace">
            <aside id="sidebar-left">
                <div class="module-section">
                    <h3>Module 0: Orientation</h3>
                    <div class="lesson-item" data-lesson="0.1">0.1 Hello, World</div>
                    <div class="lesson-item" data-lesson="0.2">0.2 MOV & ADD</div>
                    <div class="lesson-item" data-lesson="0.3">0.3 Memory</div>
                </div>
                <div class="module-section">
                    <h3>Module 1: Control & Data</h3>
                    <div class="lesson-item" data-lesson="1.1">1.1 Conditionals</div>
                    <div class="lesson-item" data-lesson="1.2">1.2 Loops</div>
                    <div class="lesson-item" data-lesson="1.3">1.3 strlen</div>
                    <div class="lesson-item" data-lesson="1.4">1.4 Checksum</div>
                    <div class="lesson-item" data-lesson="1.5">1.5 Switch/Jump Table</div>
                </div>
                <div class="module-section">
                    <h3>Module 2: Advanced</h3>
                    <div class="lesson-item" data-lesson="2.1">2.1 Calling Conv</div>
                    <div class="lesson-item" data-lesson="2.2">2.2 PLT/GOT</div>
                    <div class="lesson-item" data-lesson="2.3">2.3 Stack Canary</div>
                    <div class="lesson-item" data-lesson="2.4">2.4 Compiler</div>
                    <div class="lesson-item" data-lesson="2.5">2.5 XOR Crackme</div>
                </div>
                <div style="margin-top: 20px;">
                    <button class="btn" onclick="exportProgress()">Export Progress</button>
                </div>
            </aside>
            
            <section id="center">
                <nav class="tabs">
                    <div class="tab active" data-tab="disasm">Disassembly</div>
                    <div class="tab" data-tab="hex">Hex</div>
                    <div class="tab" data-tab="strings">Strings</div>
                    <div class="tab" data-tab="flow">Flow</div>
                    <div class="tab" data-tab="lesson">Lesson</div>
                </nav>
                <div class="view-content">
                    <div id="disasm-view">
                        <div class="disasm-row is-ip">
                            <div class="addr">0x401000</div>
                            <div class="bytes">55</div>
                            <div>push rbp</div>
                        </div>
                        <div class="disasm-row">
                            <div class="addr">0x401001</div>
                            <div class="bytes">48 89 e5</div>
                            <div>mov rbp, rsp</div>
                        </div>
                        <div class="disasm-row">
                            <div class="addr">0x401004</div>
                            <div class="bytes">c9</div>
                            <div>leave</div>
                        </div>
                        <div class="disasm-row">
                            <div class="addr">0x401005</div>
                            <div class="bytes">c3</div>
                            <div>ret</div>
                        </div>
                    </div>
                    <div id="hex-view" class="hex-view hidden">
                        <div id="hex-content">
                            <div class="hex-row">
                                <div>0x401000</div>
                                <div>55 48 89 e5 c9 c3 00 00  00 00 00 00 00 00 00 00</div>
                                <div>UH...... ........</div>
                            </div>
                        </div>
                    </div>
                    <div id="strings-view" class="hidden">
                        <div id="strings-content">
                            <div>Found strings:</div>
                            <div style="margin-top: 10px; color: var(--muted);">No strings found</div>
                        </div>
                    </div>
                    
                    <div id="flow-view" class="hidden">
                        <div style="margin-bottom: 15px; color: var(--neon); font-weight: bold;">üîÄ Control Flow Graph</div>
                        <svg id="cfg-svg" width="100%" height="400" viewBox="0 0 800 400" style="background: rgba(255,255,255,0.02); border-radius: 8px;">
                            <defs>
                                <filter id="glow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge>
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="var(--muted)" />
                                </marker>
                                <marker id="arrowhead-active" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="var(--neon)" />
                                </marker>
                            </defs>
                        </svg>
                        <div style="margin-top: 10px; font-size: 11px; color: var(--muted);">
                            üí° Click on blocks to jump to instructions
                        </div>
                    </div>
                    <div id="lesson-view" class="hidden">
                        <div id="lesson-content">
                            <div class="lesson-card">
                                <h4>Welcome to Hacker Lab!</h4>
                                <p>Select a lesson from the left sidebar to begin your journey into assembly and reverse engineering.</p>
                                <div style="margin-top: 20px; padding: 15px; background: rgba(73,247,194,0.05); border-radius: 8px; border-left: 3px solid var(--neon);">
                                    <strong>üéØ How it works:</strong><br>
                                    ‚Ä¢ Choose a lesson from the left sidebar<br>
                                    ‚Ä¢ Read the detailed explanation in this tab<br>
                                    ‚Ä¢ Use the debugger tools on the right to practice<br>
                                    ‚Ä¢ Step through code with F10 or 'si' command<br>
                                    ‚Ä¢ Check your progress with the 'check' command
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            
            <aside id="sidebar-right">
                <h4 style="margin-bottom: 12px; color: var(--neon);">Registers</h4>
                <div class="reg-grid" id="reg-grid">
                    <div class="reg-item"><div class="name">RAX</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RBX</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RCX</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RDX</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RSI</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RDI</div><div class="value">0x0000000000000000</div></div>
                    <div class="reg-item"><div class="name">RBP</div><div class="value">0x7fffffffe000</div></div>
                    <div class="reg-item"><div class="name">RSP</div><div class="value">0x7fffffffe000</div></div>
                    <div class="reg-item"><div class="name">RIP</div><div class="value">0x0000000000401000</div></div>
                </div>
                
                <h4 style="margin-bottom: 8px; color: var(--neon);">Flags</h4>
                <div class="flags">
                    <div class="flag" data-flag="zf">ZF</div>
                    <div class="flag" data-flag="sf">SF</div>
                    <div class="flag" data-flag="of">OF</div>
                    <div class="flag" data-flag="cf">CF</div>
                </div>
                
                <h4 style="margin-bottom: 8px; color: var(--neon);">Stack</h4>
                <div class="stack-view">
                    <div class="stack-item"><div>0x7ffe000</div><div>0x0000000000401010</div></div>
                    <div class="stack-item"><div>0x7fffdf8</div><div>0x00007fff12345678</div></div>
                </div>
                
                <div style="margin: 15px 0;">
                    <h4 style="color: var(--neon); margin-bottom: 8px;">üîç Quick Actions</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 12px;">
                        <button class="btn" onclick="runCmd('si')" title="Step one instruction">‚û°Ô∏è Step</button>
                        <button class="btn" onclick="runCmd('c')" title="Continue execution">‚ñ∂Ô∏è Run</button>
                        <button class="btn" onclick="runCmd('regs')" title="Show all registers">üìä Regs</button>
                        <button class="btn" onclick="runCmd('stack')" title="Show stack contents">üìö Stack</button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                        <button class="btn" onclick="runCmd('flow')" title="View control flow graph">üîÄ Flow</button>
                        <button class="btn" onclick="runCmd('bps')" title="Show breakpoints">üî¥ BPs</button>
                    </div>
                </div>
                
                <div class="lesson-card" id="lesson-status">
                    <h4>üõ†Ô∏è Debugger Panel</h4>
                    <p>No lesson loaded</p>
                    <div style="margin-top: 12px;">
                        <button class="btn" onclick="runCmd('help')">Help</button>
                        <button class="btn" onclick="runCmd('levels')">Levels</button>
                    </div>
                </div>
            </aside>
        </main>

        <!-- Qoder Modal -->
        <div id="qoder-modal" class="modal hidden">
            <div class="modal-overlay"></div>
            <div class="modal-card">
                <div class="modal-header">
                    <div>ü§ñ Qoder ‚Äî –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —É—Ä–æ–∫–æ–≤</div>
                    <button id="qoder-close" class="btn danger" style="padding:6px 10px;">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="q-grid">
                        <label>Lesson ID</label>
                        <input id="q-id" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: 3.1" />
                        <label>Title</label>
                        <input id="q-title" placeholder="–Ω–∞–ø—Ä–∏–º–µ—Ä: Arithmetic II ‚Äî mov/add" />
                        <label>Template</label>
                        <select id="q-template">
                            <option value="mov_add">Arithmetic (mov + add)</option>
                            <option value="loop_rcx">Loop RCX‚Üí0 (dec/jnz)</option>
                            <option value="xor_byte">XOR single-byte (rax ‚äï key)</option>
                            <option value="stack_var">Stack var [rbp-8] store/load</option>
                            <option value="plt_got">PLT/GOT (puts@plt)</option>
                            <option value="call_chain">Call/Ret chain</option>
                            <option value="jump_table">Jump table (switch)</option>
                            <option value="memcpy_rep">memcpy (REP MOVSQ)</option>
                            <option value="cmp_signed_unsigned">Signed vs Unsigned (JL/JB)</option>
                            <option value="bit_hacks">Bit hacks (BT/BTC/BTR)</option>
                            <option value="rip_lea_pic">RIP-relative LEA (PIC)</option>
                            <option value="pic_qword_table">PIC QWORD table (RIP-relative)</option>
                            <option value="memset_rep_stos">memset (REP STOSB/STOSQ)</option>
                            <option value="cmov_min">CMOVcc ‚Äî min(a,b)</option>
                            <option value="setcc_flags">SETcc ‚Äî flags to byte</option>
                            <option value="plt_got_second_call">PLT/GOT ‚Äî second call (GOT patched)</option>
                            <option value="cmov_min_unsigned">CMOVcc ‚Äî unsigned min(a,b)</option>
                            <option value="setcc_unsigned">SETcc ‚Äî unsigned (A/AE/B/BE)</option>
                            <option value="pic_string_lods_stos">PIC string table (LODSB/STOSB)</option>
                            <option value="sse_mini">SSE/AVX mini idioms (PXOR/PADDB/MOVDQU)</option>
                            <option value="abi_fastcall_vs_sysv">ABI compare ‚Äî fastcall vs SysV</option>
                            <option value="plt_got_third_call">PLT/GOT ‚Äî 3-–π –≤—ã–∑–æ–≤ (no-op, GOT —É–∂–µ –ø–∞—Ç—á–µ–Ω)</option>
                            <option value="cmov_max_signed">CMOVcc ‚Äî signed max(a,b)</option>
                            <option value="cmov_max_unsigned">CMOVcc ‚Äî unsigned max(a,b)</option>
                            <option value="setcc_signed">SETcc ‚Äî signed (L/LE/G/GE)</option>
                            <option value="lea_scaled_index">LEA ‚Äî —Å–ª–æ–∂–Ω–∞—è –∞–¥—Ä–µ—Å–∞—Ü–∏—è [base + index*scale + imm]</option>
                            <option value="combo_eq_neq">Combo checks ‚Äî (a==b) && (c!=d)</option>
                            <option value="lea_struct_stride">LEA + IMUL ‚Äî –º–∞—Å—Å–∏–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä —Å–æ stride</option>
                            <option value="overflow_detect_of">OF detection ‚Äî add + JO/JNO</option>
                            <option value="adc_sbb_128">128-bit add ‚Äî ADD/ADC (low/high)</option>
                            <option value="retpoline_demo">Retpoline (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è)</option>
                            <option value="tail_call_opt">Tail call optimization (jmp –≤–º–µ—Å—Ç–æ ret)</option>
                            <option value="sbb_128_sub">128-bit sub ‚Äî SUB/SBB (borrow)</option>
                            <option value="range_check_inclusive">Range check: lo ‚â§ x ‚â§ hi (SETcc)</option>
                            <option value="saturating_add_i8">Saturating add (int8)</option>
                            <option value="plt_got_lazy_full">PLT/GOT ‚Äî lazy resolve (1‚Üí2‚Üí3)</option>
                            <option value="bitpack_extract_lea">Bitpack extract ‚Äî (x>>shift)&mask (LEA+SHR/AND)</option>
                            <option value="saturating_sub_i8">Saturating sub (int8)</option>
                            <option value="bitcount_clz_ctz_popcnt">Bitcount ‚Äî CLZ/CTZ/POPCNT (—Å–∏–º–≤.)</option>
                            <option value="bmi2_pext_pdep">BMI2 ‚Äî PEXT/PDEP (—Å–∏–º–≤.)</option>
                            <option value="memcpy_sse_vs_rep">memcpy: SSE movdqu vs rep movsb</option>
                            <option value="pic_rip_printf">ASLR/PIC: RIP-relative + printf@plt</option>
                            <option value="tls_canary_paths">TLS canary: fast/slow path</option>
                            <option value="bmi2_pext_pdep64_step">BMI2 64-bit: gather‚Üíscatter (step)</option>
                            <option value="saturating_mul_i32x4_vector">Vector Saturating mul (int32x4) ‚Äî SSE/NEON (symbolic)</option>
                            <option value="arm64_sqrdmulh_q31">ARM64: SQRDMULH (Q31, symbolic)</option>
                            <option value="bmi2_pext_pdep64_interactive">BMI2: PEXT/PDEP Interactive</option>
                            <option value="regdiff_demo">Register Diff (demo)</option>
                            <option value="ctf_magic_div_u32">CTF: Magic Division (u32)</option>
                        </select>
                        <div class="q-params" id="q-params"></div>
                    </div>
                    <div style="margin-top:12px;display:flex;gap:8px;">
                        <button id="q-preview" class="btn">üëÅÔ∏è Preview</button>
                        <button id="q-insert" class="btn success">‚ûï Insert</button>
                        <button id="q-export" class="btn">üíæ Export</button>
                        <button id="q-import" class="btn">üì• Import</button>
                    </div>
                    <pre id="q-output" class="q-output"></pre>
                </div>
            </div>
        </div>
        <section id="terminal">
            <div id="term-header">Terminal - Type 'help' for commands</div>
            <div id="term-body">
                <div>Welcome to Hacker Lab! Type 'help' for available commands.</div>
                <div>Use F10 to step, F9 to continue, or type commands directly.</div>
                <div></div>
            </div>
            <div id="term-input-row">
                <span id="term-prompt">(hlab)></span>
                <input type="text" id="term-input" class="caret" placeholder="Type command..." autocomplete="off">
            </div>
        </section>
    </div>

<script>
// ===== QODER: minimal lesson generator + auto-trace =====
const QODER_LS_KEY = 'hl_custom_lessons_v2';

const Qoder = {
    templates: {
        mov_add: {
            label: 'Arithmetic (mov + add)',
            params: [
                {key:'imm1',label:'imm1 (hex)',def:'0x10'},
                {key:'imm2',label:'imm2 (hex)',def:'0x27'},
                {key:'strings',label:'strings',def:'Math via mov/add'}
            ],
            build: (p) => {
                const imm1 = parseInt(p.imm1,16);
                const imm2 = parseInt(p.imm2,16);
                const base = 0x401000;
                const disasm = [
                    {a:base+0x00, b:'48 c7 c0 '+toImm32(imm1), s:`mov rax, 0x${imm1.toString(16)}`},
                    {a:base+0x07, b:'48 83 c0 '+toImm8(imm2), s:`add rax, 0x${imm2.toString(16)}`},
                    {a:base+0x0b, b:'c3', s:'ret'}
                ];
                const trace = [
                    {ip:0, regs:{rax:BigInt(imm1)}, note:`RAX ‚Üê ${imm1} (0x${imm1.toString(16)})`},
                    {ip:1, regs:{rax:BigInt(imm1+imm2)}, note:`ADD ${imm2} ‚áí RAX=${imm1+imm2}`},
                    {ip:2, note:'Return'}
                ];
                return {
                    id:'', title:'üßÆ Arithmetic ‚Äî mov/add',
                    goal:`Make RAX = ${imm1+imm2} (0x${(imm1+imm2).toString(16)})`,
                    hint:'Step over mov/add; check RAX',
                    explanation:`Simple arithmetic with MOV+ADD.`,
                    base, strings:[p.strings||'Arithmetic'], disasm, cfg:linearCFG(disasm,'Arithmetic'),
                    trace, check:(s)=>s.regs.rax===BigInt(imm1+imm2)
                };
            }
        },

        loop_rcx: {
            label:'Loop RCX‚Üí0 (dec/jnz)',
            params:[
                {key:'start',label:'start (dec count)',def:'3'},
                {key:'strings',label:'strings',def:'Loop demo'}
            ],
            build: (p) => {
                const n = parseInt(p.start,10);
                const base = 0x401000;
                const disasm = [
                    {a:base+0x00, b:'48 c7 c1 '+toImm32(n), s:`mov rcx, ${n}`},
                    {a:base+0x07, b:'48 ff c9', s:'dec rcx'},
                    {a:base+0x0a, b:'75 fb', s:'jnz 0x401007'},
                    {a:base+0x0c, b:'c3', s:'ret'}
                ];
                // –∞–≤—Ç–æ—Ç—Ä–µ–π—Å
                const trace = [{ip:0, regs:{rcx:BigInt(n)}, note:`RCX=${n}`}];
                for(let i=n;i>0;i--){
                    trace.push({ip:1, regs:{rcx:BigInt(i-1)}, flags:{zf: i-1===0?1:0}, note:`dec ‚Üí ${i-1}`});
                    if(i-1!==0) trace.push({ip:2,note:'jnz back'});
                }
                trace.push({ip:3,note:'ret'});
                return {
                    id:'', title:'üîÑ Loop RCX',
                    goal:'RCX must end at 0',
                    hint:'dec/jnz until zero',
                    explanation:'Classic countdown loop.',
                    base, strings:[p.strings||'Loop'], disasm, cfg:loopCFG(),
                    trace, check:(s)=>s.regs.rcx===0n
                };
            }
        },

        xor_byte: {
            label:'XOR single-byte (rax ‚äï key)',
            params:[
                {key:'val',label:'val (hex)',def:'0x71'},
                {key:'key',label:'key (hex)',def:'0x42'},
                {key:'expect',label:'expect (hex)',def:'0x33'}
            ],
            build:(p)=>{
                const v=parseInt(p.val,16), k=parseInt(p.key,16), e=parseInt(p.expect,16);
                const base=0x401000;
                const disasm = [
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(v), s:`mov rax, 0x${v.toString(16)}`},
                    {a:base+0x07,b:'48 c7 c1 '+toImm32(k), s:`mov rcx, 0x${k.toString(16)}`},
                    {a:base+0x0e,b:'48 31 c8', s:'xor rax, rcx'},
                    {a:base+0x11,b:'48 83 f8 '+toImm8(e), s:`cmp rax, 0x${e.toString(16)}`},
                    {a:base+0x15,b:'74 05', s:'jz success'},
                    {a:base+0x17,b:'48 c7 c0 ff ff ff ff', s:'mov rax, -1'},
                    {a:base+0x1e,b:'c3', s:'ret'},
                    {a:base+0x1c,b:'48 c7 c0 01 00 00 00', s:'mov rax, 1'},
                    {a:base+0x23,b:'c3', s:'ret'}
                ];
                const ok = (v^k)===e;
                const trace = [
                    {ip:0, regs:{rax:BigInt(v)}, note:`RAX=${hexs(v)}`},
                    {ip:1, regs:{rcx:BigInt(k)}, note:`RCX=${hexs(k)}`},
                    {ip:2, regs:{rax:BigInt(v^k)}, note:`XOR ‚Üí ${hexs(v^k)}`},
                    {ip:3, flags:{zf: ok?1:0}, note:`cmp with ${hexs(e)}; ZF=${ok?1:0}`},
                    {ip: ok?4:5, note: ok?'jump to success':'fall to fail'},
                    ...(ok?[{ip:7, regs:{rax:1n}}, {ip:8}]:[{ip:6, regs:{rax:-1n}},{ip:6}])
                ];
                return {
                    id:'', title:'üîê XOR Byte',
                    goal:`Decrypt to ${hexs(e)}`,
                    hint:'XOR is its own inverse',
                    explanation:'Mini crackme with XOR.',
                    base, strings:[`Encrypted: ${hexs(v)}`,`Key: ${hexs(k)}`,`Target: ${hexs(e)}`],
                    disasm, cfg:branchCFG(), trace,
                    check:(s)=> (v^k)===e ? s.regs.rax===1n : s.regs.rax===-1n
                };
            }
        },

        stack_var: {
            label:'Stack var [rbp-8]',
            params:[
                {key:'value',label:'value (int)',def:'42'}
            ],
            build:(p)=>{
                const val=parseInt(p.value,10);
                const base=0x401000;
                const disasm = [
                    {a:base+0x00,b:'55',s:'push rbp'},
                    {a:base+0x01,b:'48 89 e5',s:'mov rbp, rsp'},
                    {a:base+0x04,b:'48 c7 45 f8 '+toImm32(val),s:`mov [rbp-8], ${val}`},
                    {a:base+0x0c,b:'48 8b 45 f8',s:'mov rax, [rbp-8]'},
                    {a:base+0x10,b:'5d',s:'pop rbp'},
                    {a:base+0x11,b:'c3',s:'ret'}
                ];
                const trace = [
                    {ip:0, regs:{rsp:0x7fffffffe000n-8n}, note:'push rbp'},
                    {ip:1, regs:{rbp:0x7fffffffe000n-8n}, note:'frame'},
                    {ip:2, stack:[BigInt(val)], note:`store ${val}`},
                    {ip:3, regs:{rax:BigInt(val)}, note:'load ‚Üí RAX'},
                    {ip:4, regs:{rbp:0x7fffffffe000n}, note:'leave'},
                    {ip:5, note:'ret'}
                ];
                return {
                    id:'', title:'üíæ Stack var',
                    goal:`RAX must be ${val}`,
                    hint:'Write then read',
                    explanation:'Local stack variable demo.',
                    base, strings:[`Local variable: ${val}`],
                    disasm, cfg:linearCFG(disasm,'Stack var'),
                    trace, check:(s)=>s.regs.rax===BigInt(val)
                };
            }
        },

        // === PLT/GOT mini ===
        plt_got: {
            label: 'PLT/GOT (puts@plt)',
            params: [
                {key:'msg',label:'string literal',def:'Hello from puts!'},
                {key:'sym',label:'symbol',def:'puts@plt'}
            ],
            build:(p)=>{
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c7 10 20 40 00',s:'mov rdi, 0x402010'},
                    {a:base+0x07,b:'e8 04 00 00 00',s:'call 0x401010'},
                    {a:base+0x0c,b:'c3',s:'ret'},
                    {a:base+0x10,b:'ff 25 02 2f 00 00',s:'jmp QWORD PTR [rip+0x2f02]'},
                    {a:base+0x16,b:'68 00 00 00 00',s:'push 0x0'},
                    {a:base+0x1b,b:'e9 e0 fe ff ff',s:'jmp 0x401000'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:0x402010n}, note:`RDI ‚Üí "${p.msg}"`},
                    {ip:1, note:`call ${p.sym}`},
                    {ip:3, note:'PLT jmp ‚Üí GOT resolver on first call'},
                    {ip:4, note:'push symbol index for resolver'},
                    {ip:5, note:'jmp dynamic linker'},
                    {ip:2, note:'ret (after libc puts)'}
                ];
                return {
                    id:'', title:'üîó PLT/GOT ‚Äî dynamic call',
                    goal:'Understand PLT/GOT first-call flow',
                    hint:'call ‚Üí PLT ‚Üí GOT ‚Üí resolver ‚Üí real func',
                    explanation:`Classic ELF lazy binding: first call goes via resolver, then GOT patched.`,
                    base, strings:[p.msg, p.sym, 'libc.so.6'],
                    disasm, cfg:callCFG('main','puts@plt'),
                    trace, check:(s)=> s.ipIndex>=2
                };
            }
        },

        // === Call/Ret chain (nested) ===
        call_chain: {
            label:'Call/Ret chain',
            params:[
                {key:'a',label:'arg a (RDI)',def:'16'},
                {key:'b',label:'arg b (RSI)',def:'32'}
            ],
            build:(p)=>{
                const a=parseInt(p.a,10), b=parseInt(p.b,10);
                const sum=a+b;
                const base=0x401000;
                const disasm=[
                    // main:
                    {a:base+0x00,b:'48 c7 c7 '+toImm32(a),s:`mov rdi, ${a}`},
                    {a:base+0x07,b:'48 c7 c6 '+toImm32(b),s:`mov rsi, ${b}`},
                    {a:base+0x0e,b:'e8 09 00 00 00',s:'call 0x401022'}, // call add
                    {a:base+0x13,b:'c3',s:'ret'},

                    // add(a,b):
                    {a:base+0x22,b:'55',s:'push rbp'},
                    {a:base+0x23,b:'48 89 e5',s:'mov rbp, rsp'},
                    {a:base+0x26,b:'48 89 7d f8',s:'mov [rbp-8], rdi'},
                    {a:base+0x2a,b:'48 89 75 f0',s:'mov [rbp-16], rsi'},
                    {a:base+0x2e,b:'48 8b 45 f8',s:'mov rax, [rbp-8]'},
                    {a:base+0x32,b:'48 03 45 f0',s:'add rax, [rbp-16]'},
                    {a:base+0x36,b:'5d',s:'pop rbp'},
                    {a:base+0x37,b:'c3',s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:BigInt(a)}, note:`main: RDI=${a}`},
                    {ip:1, regs:{rsi:BigInt(b)}, note:`main: RSI=${b}`},
                    {ip:2, note:'call add(a,b)'},
                    {ip:4, note:'prologue'},
                    {ip:6, note:'save args on stack'},
                    {ip:8, regs:{rax:BigInt(a)}, note:'load a'},
                    {ip:9, regs:{rax:BigInt(sum)}, note:`add b ‚Üí ${sum}`},
                    {ip:11, note:'ret to main'},
                    {ip:3, note:'main: ret with RAX result'}
                ];
                return {
                    id:'', title:'üìû Call chain ‚Äî main ‚Üí add',
                    goal:`RAX must be ${sum}`,
                    hint:'Observe prologue/epilogue and ABI regs',
                    explanation:'–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –≤—ã–∑–æ–≤–∞, –ª–æ–∫–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –≤–æ–∑–≤—Ä–∞—Ç–∞.',
                    base, strings:['add(a,b)','System V ABI'],
                    disasm, cfg:callCFG('main','add'),
                    trace, check:(s)=> s.regs.rax===BigInt(sum)
                };
            }
        },

        // === Jump table (switch) ===
        jump_table: {
            label:'Jump table (switch)',
            params:[
                {key:'case',label:'desired case',def:'2'},
                {key:'v0',label:'case0 RAX',def:'0x100'},
                {key:'v1',label:'case1 RAX',def:'0x111'},
                {key:'v2',label:'case2 RAX',def:'0x222'},
                {key:'v3',label:'case3 RAX',def:'0x333'},
            ],
            build:(p)=>{
                const want=parseInt(p.case,10);
                const v0=parseInt(p.v0,16), v1=parseInt(p.v1,16),
                      v2=parseInt(p.v2,16), v3=parseInt(p.v3,16);
                const vals=[v0,v1,v2,v3];
                const base=0x401000;

                // –∞–¥—Ä–µ—Å–∞ —Ö—ç–Ω–¥–ª–µ—Ä–æ–≤
                const h0=base+0x14, h1=base+0x1c, h2=base+0x24, h3=base+0x2c, def=base+0x34, jpt=base+0x40;

                const disasm=[
                    {a:base+0x00,b:'48 c7 c7 '+toImm32(want),s:`mov rdi, ${want}`},
                    {a:base+0x07,b:'48 83 ff 03',s:'cmp rdi, 3'},
                    {a:base+0x0b,b:'77 13',s:'ja 0x'+def.toString(16)},
                    {a:base+0x0d,b:'ff 24 fd '+toImm32(jpt),s:'jmp QWORD PTR [rdi*8+'+hexs(jpt)+']'},
                    // handlers
                    {a:h0,b:'48 c7 c0 '+toImm32(v0),s:`mov rax, ${hexs(v0)}`},
                    {a:h0+7,b:'c3',s:'ret'},
                    {a:h1,b:'48 c7 c0 '+toImm32(v1),s:`mov rax, ${hexs(v1)}`},
                    {a:h1+7,b:'c3',s:'ret'},
                    {a:h2,b:'48 c7 c0 '+toImm32(v2),s:`mov rax, ${hexs(v2)}`},
                    {a:h2+7,b:'c3',s:'ret'},
                    {a:h3,b:'48 c7 c0 '+toImm32(v3),s:`mov rax, ${hexs(v3)}`},
                    {a:h3+7,b:'c3',s:'ret'},
                    {a:def,b:'48 c7 c0 ff ff ff ff',s:'mov rax, -1'},
                    {a:def+7,b:'c3',s:'ret'},
                    // jump table (–ø—Å–µ–≤–¥–æ, –∞–¥—Ä–µ—Å–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–∏–∑–∞—Å–º–∞ –º—ã –ø—Ä–æ—Å—Ç–æ –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ–º)
                ];
                const trace=[
                    {ip:0, regs:{rdi:BigInt(want)}, note:`switch value = ${want}`},
                    {ip:1, note:'cmp rdi,3'},
                    {ip:2, note: want>3?'ja default':'no ja (‚â§3)'},
                    {ip:3, note:`jmp [table + ${want}*8] ‚Üí handler ${want}`},
                    // –ø–µ—Ä–µ–π–¥—ë–º –∫ –Ω—É–∂–Ω–æ–º—É handler ip:
                    ...(want===0?[{ip:4, regs:{rax:BigInt(v0)}},{ip:5}]:[]),
                    ...(want===1?[{ip:6, regs:{rax:BigInt(v1)}},{ip:7}]:[]),
                    ...(want===2?[{ip:8, regs:{rax:BigInt(v2)}},{ip:9}]:[]),
                    ...(want===3?[{ip:10,regs:{rax:BigInt(v3)}},{ip:11}]:[]),
                    ...(want>3 ? [{ip:12, regs:{rax:-1n}},{ip:13}] : [])
                ];
                const expect = want>3 ? -1n : BigInt(vals[want]);
                return {
                    id:'', title:'üîÄ Jump Table ‚Äî switch',
                    goal:`RAX must be ${expect<0n?'-1':hexs(Number(expect))}`,
                    hint:'rdi = case; jmp [table + rdi*8]',
                    explanation:'–ë—ã—Å—Ç—Ä—ã–π switch —á–µ—Ä–µ–∑ —Ç–∞–±–ª–∏—Ü—É –ø–µ—Ä–µ—Ö–æ–¥–æ–≤ (PC-relative addressing).',
                    base, strings:['jump table','switch'],
                    disasm, cfg:tableCFG(['case0','case1','case2','case3','default']),
                    trace, check:(s)=> s.regs.rax===expect
                };
            }
        },

        // === memcpy via REP MOVSQ (16 bytes) ===
        memcpy_rep: {
            label: 'memcpy (REP MOVSQ)',
            params: [
                {key:'len_qwords', label:'qwords (√ó8 bytes)', def:'2'},
                {key:'dst', label:'dst (hex)', def:'0x402000'},
                {key:'src', label:'src (hex)', def:'0x403000'}
            ],
            build:(p)=>{
                const cnt = Math.max(1, parseInt(p.len_qwords,10) || 2);
                const dst = parseInt(p.dst,16)||0x402000, src=parseInt(p.src,16)||0x403000;
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c7 '+toImm32(dst), s:`mov rdi, ${hexs(dst)}`},   // dst
                    {a:base+0x07,b:'48 c7 c6 '+toImm32(src), s:`mov rsi, ${hexs(src)}`},   // src
                    {a:base+0x0e,b:'48 c7 c1 '+toImm32(cnt), s:`mov rcx, ${cnt}`},         // count (qwords)
                    {a:base+0x15,b:'f3 48 a5', s:'rep movsq'},                             // copy
                    {a:base+0x18,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:BigInt(dst)}, note:`RDI=dst`},
                    {ip:1, regs:{rsi:BigInt(src)}, note:`RSI=src`},
                    {ip:2, regs:{rcx:BigInt(cnt)}, note:`RCX=count (${cnt}√ó8B=${cnt*8*1}B)`},
                    {ip:3, regs:{rcx:0n, rdi:BigInt(dst+cnt*8), rsi:BigInt(src+cnt*8)}, note:`rep movsq ‚Üí copied ${cnt*8} bytes`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üöö memcpy ‚Äî REP MOVSQ',
                    goal:`RCX must be 0 and RDI,RSI advanced by ${cnt*8} bytes`,
                    hint:'mov rdi,rsi; mov rcx; rep movsq',
                    explanation:'–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –∫–æ–¥ memcpy, —É—Å–∫–æ—Ä–µ–Ω–Ω—ã–π —á–µ—Ä–µ–∑ REP MOVSQ.',
                    base, strings:['memcpy','rep movsq'],
                    disasm, cfg:linearCFG(disasm,'memcpy'),
                    trace, check:(s)=> s.regs.rcx===0n && s.regs.rdi===BigInt(dst+cnt*8) && s.regs.rsi===BigInt(src+cnt*8)
                };
            }
        },

        // === Signed vs Unsigned compare: JL vs JB ===
        cmp_signed_unsigned: {
            label:'Signed vs Unsigned (JL/JB)',
            params:[
                {key:'a', label:'RAX (hex)', def:'0xfffffffffffffffe'}, // -2 signed
                {key:'b', label:'RBX (hex)', def:'0x1'}
            ],
            build:(p)=>{
                const a=parseInt(p.a,16)>>>0; // we'll reason symbolically in notes
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 b8 fe ff ff ff ff ff ff ff', s:'mov rax, 0xfffffffffffffffe'},
                    {a:base+0x0a,b:'48 bb 01 00 00 00 00 00 00 00', s:'mov rbx, 0x1'},
                    {a:base+0x14,b:'48 39 d8', s:'cmp rax, rbx'},
                    {a:base+0x17,b:'7c 07', s:'jl signed_less'},
                    {a:base+0x19,b:'72 0a', s:'jb unsigned_below'},
                    {a:base+0x1b,b:'48 c7 c0 00 00 00 00', s:'mov rax, 0'}, // default
                    {a:base+0x22,b:'c3', s:'ret'},
                    // signed_less:
                    {a:base+0x23,b:'48 c7 c0 11 00 00 00', s:'mov rax, 0x11'},
                    {a:base+0x2a,b:'c3', s:'ret'},
                    // unsigned_below:
                    {a:base+0x2b,b:'48 c7 c0 22 00 00 00', s:'mov rax, 0x22'},
                    {a:base+0x32,b:'c3', s:'ret'}
                ];
                // –í–∞–∂–Ω–∞—è –∏–¥–µ—è: 0xffff...fffe < 1 –ø–æ –∑–Ω–∞–∫—É (‚àí2 < 1), –Ω–æ unsigned ‚Äî –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ > 1.
                const trace=[
                    {ip:0, regs:{rax:0xfffffffffffen}, note:'RAX = -2 (signed), huge (unsigned)'},
                    {ip:1, regs:{rbx:0x1n}, note:'RBX = 1'},
                    {ip:2, note:'cmp rax,rbx ‚Üí SF‚â†OF (signed less), CF=0 (unsigned not below)'},
                    {ip:3, note:'jl taken (signed -2 < 1)'},
                    {ip:7, regs:{rax:0x11n}, note:'RAX=0x11 (signed path)'},
                    {ip:8, note:'ret'}
                ];
                return {
                    id:'', title:'‚öñÔ∏è Signed vs Unsigned',
                    goal:'–ü—Ä–æ–π—Ç–∏ –ø–æ signed –≤–µ—Ç–∫–µ (RAX=0x11) –∏ –Ω–µ –ø–æ–ø–∞—Å—Ç—å –≤ unsigned',
                    hint:'-2 < 1 –ø–æ –∑–Ω–∞–∫—É, –Ω–æ –Ω–µ –Ω–∏–∂–µ –ø–æ unsigned',
                    explanation:'JL –∏—Å–ø–æ–ª—å–∑—É–µ—Ç SF‚â†OF, –∞ JB –∏—Å–ø–æ–ª—å–∑—É–µ—Ç CF=1. –ù–∞ –ø—Ä–∏–º–µ—Ä–µ -2 vs 1 –≤–∏–¥–Ω–æ —Ä–∞–∑–ª–∏—á–∏–µ.',
                    base, strings:['cmp signed/unsigned','flags'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> s.regs.rax===0x11n
                };
            }
        },

        // === Bit hacks: BT/BTC/BTR (probe & toggle/clear bit) ===
        bit_hacks: {
            label:'Bit hacks (BT/BTC/BTR)',
            params:[
                {key:'val', label:'initial RAX (hex)', def:'0b10110'},
                {key:'bit', label:'bit index', def:'1'}, // –ø—Ä–æ–≤–µ—Ä–∏—Ç—å 1-–π –±–∏—Ç
                {key:'op',  label:'op (bt|btc|btr)', def:'btc'}
            ],
            build:(p)=>{
                // —É–ø—Ä–æ—Å—Ç–∏–º: –ø—Ä–∏–Ω–∏–º–∞–µ–º –¥–µ—Å—è—Ç–∏—á–Ω—ã–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
                const parseBinHex = (s)=>{
                    if(/^0b[01]+$/i.test(s)) return parseInt(s.slice(2),2);
                    if(/^0x/i.test(s)) return parseInt(s,16);
                    return parseInt(s,10);
                };
                const val=parseBinHex(p.val||'0b10110')|0;
                const bit=parseInt(p.bit,10)|0;
                const op=(p.op||'btc').toLowerCase();
                const base=0x401000;

                // bytes ‚Äî —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–ª—è —Ç—Ä–µ–Ω–∞–∂—ë—Ä–∞
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(val), s:`mov rax, ${val}`},
                    {a:base+0x07,b:'48 c7 c1 '+toImm32(bit), s:`mov rcx, ${bit}`},
                    {a:base+0x0e,b: op==='bt' ? '48 0f a3 c8' : (op==='btc' ? '48 0f bb c8' : '48 0f b3 c8'),
                     s: op==='bt' ? 'bt rax, rcx' : (op==='btc' ? 'btc rax, rcx' : 'btr rax, rcx')},
                    {a:base+0x12,b:'73 05', s:'jae no_carry'}, // CF=0 ‚Üí no_carry
                    {a:base+0x14,b:'48 c7 c2 01 00 00 00', s:'mov rdx, 1'}, // carry path (CF=1)
                    {a:base+0x1b,b:'eb 03', s:'jmp done'},
                    {a:base+0x1d,b:'48 31 d2', s:'xor rdx, rdx'},            // no_carry: RDX=0
                    {a:base+0x20,b:'c3', s:'done: ret'}
                ];

                const wasSet = ((val >>> bit) & 1) === 1;
                let newVal = val;
                if (op==='btc') newVal = val ^ (1<<bit);      // toggle
                else if (op==='btr') newVal = val & ~(1<<bit);// clear
                // bt –Ω–µ –º–µ–Ω—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ
                const CF = wasSet ? 1 : 0;

                const trace=[
                    {ip:0, regs:{rax:BigInt(val)}, note:`RAX=${val} (bin ${val.toString(2)})`},
                    {ip:1, regs:{rcx:BigInt(bit)}, note:`bit index=${bit}`},
                    {ip:2, regs:{rax:BigInt(newVal)}, flags:{cf: CF}, note:`${op.toUpperCase()} bit ${bit} ‚Üí CF=${CF}, RAX=${newVal}`},
                    {ip:3, note:`branch by CF ‚Üí ${CF? 'carry':'no_carry'}`},
                    ...(CF ? [{ip:4, regs:{rdx:1n}}, {ip:5}] : [{ip:6, regs:{rdx:0n}}]),
                    {ip:7, note:'ret'}
                ];

                return {
                    id:'', title:`üß© Bit hacks ‚Äî ${op.toUpperCase()}`,
                    goal:`RDX must indicate CF (${CF}) and RAX reflect ${op==='bt'?'no change':op}`,
                    hint:'BT sets CF, BTC toggles bit, BTR clears bit',
                    explanation:'BT/BTC/BTR: –±—ã—Å—Ç—Ä—ã–µ –±–∏—Ç–æ–≤—ã–µ –ø—Ä–∏–º–∏—Ç–∏–≤—ã ‚Äî –ø—Ä–æ–≤–µ—Ä–∫–∞, –∏–Ω–≤–µ—Ä—Å–∏—è, —Å–±—Ä–æ—Å.',
                    base, strings:['bit test','btc/btr'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> s.flags.cf===CF && s.regs.rax===BigInt(newVal) && s.regs.rdx===BigInt(CF?1:0)
                };
            }
        },

        // === RIP-relative LEA (PIC addressing) ===
        rip_lea_pic: {
            label:'RIP-relative LEA (PIC)',
            params:[
                {key:'target', label:'target (hex)', def:'0x404000'}
            ],
            build:(p)=>{
                const tgt = parseInt(p.target,16)||0x404000;
                const base=0x401000;
                // –°—ã–º–∏—Ç–∏—Ä—É–µ–º RIP-rel: lea rdi, [rip+imm] ‚Üí rdi = next_ip + imm
                // –í–æ–∑—å–º—ë–º next_ip = addr –ø–æ—Å–ª–µ LEA (base+0x07)
                const nextIP = base+0x07;
                const imm = tgt - nextIP; // —Ç–∞–∫ —á—Ç–æ–±—ã –ø–æ–ø–∞–ª–∏ –≤ —Ü–µ–ª–µ–≤–æ–π
                const immHex = toImm32((imm>>>0));
                const disasm=[
                    {a:base+0x00,b:'48 8d 3d '+immHex, s:`lea rdi, [rip+${imm}] ; ‚Üí ${hexs(tgt)}`},
                    {a:base+0x07,b:'48 c7 c0 2a 00 00 00', s:'mov rax, 42'},
                    {a:base+0x0e,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rip:BigInt(nextIP), rdi:BigInt(tgt)}, note:`RDI = RIP(next) + ${imm} = ${hexs(tgt)}`},
                    {ip:1, regs:{rax:42n}, note:'mov rax,42'},
                    {ip:2, note:'ret'}
                ];
                return {
                    id:'', title:'üìç RIP-relative LEA (PIC)',
                    goal:`RDI must equal ${hexs(tgt)}`,
                    hint:'LEA RDI,[RIP+imm] = (addr of next instr) + imm',
                    explanation:'PIC/ELF –∏—Å–ø–æ–ª—å–∑—É—é—Ç RIP-relative –∞–¥—Ä–µ—Å–∞—Ü–∏—é –¥–ª—è –∫–æ–Ω—Å—Ç–∞–Ω—Ç/—Ç–∞–±–ª–∏—Ü –±–µ–∑ –∞–±—Å–æ–ª—é—Ç–Ω—ã—Ö —Å—Å—ã–ª–æ–∫.',
                    base, strings:['PIC','RIP-relative'],
                    disasm, cfg:linearCFG(disasm,'RIP-LEA'),
                    trace, check:(s)=> s.regs.rdi===BigInt(tgt)
                };
            }
        },
        // === PIC QWORD table (RIP-relative data load) ===
        pic_qword_table: {
            label:'PIC QWORD table (RIP-relative)',
            params:[
                {key:'i', label:'index (0..3)', def:'2'},
                {key:'t0',label:'QWORD0 (hex)', def:'0x1111111111111111'},
                {key:'t1',label:'QWORD1 (hex)', def:'0x2222222222222222'},
                {key:'t2',label:'QWORD2 (hex)', def:'0x3333333333333333'},
                {key:'t3',label:'QWORD3 (hex)', def:'0x4444444444444444'}
            ],
            build:(p)=>{
                const idx = Math.max(0, Math.min(3, parseInt(p.i,10)|0));
                const vals = [p.t0,p.t1,p.t2,p.t3].map(x=>BigInt(parseInt(x,16)));
                const base=0x401000;
                // —Å–º–æ–¥–µ–ª–∏—Ä—É–µ–º: lea rbx, [rip+table]; mov rax, [rbx+rcx*8]
                const nextIP = base+0x0a;                  // –ø–æ—Å–ª–µ LEA
                const tableAddr = 0x402100;                // —Ñ–∏–∫—Ç–∏–≤–Ω—ã–π –∞–¥—Ä–µ—Å —Å–µ–∫—Ü–∏–∏ .rodata
                const imm = tableAddr - nextIP;            // rip-relative —Å–º–µ—â–µ–Ω–∏–µ
                const disasm=[
                    {a:base+0x00,b:'48 c7 c1 '+toImm32(idx), s:`mov rcx, ${idx}`},
                    {a:base+0x07,b:'48 8d 1d '+toImm32((imm>>>0)), s:`lea rbx, [rip+${imm}] ; ‚Üí ${hexs(tableAddr)}`},
                    {a:base+0x0d,b:'48 8b 04 cb', s:'mov rax, [rbx+rcx*8]'},
                    {a:base+0x11,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rcx:BigInt(idx)}, note:`index=${idx}`},
                    {ip:1, regs:{rbx:BigInt(tableAddr)}, note:`RBX ‚Üí table @ ${hexs(tableAddr)}`},
                    {ip:2, regs:{rax:vals[idx]}, note:`RAX ‚Üê table[idx] = ${'0x'+vals[idx].toString(16)}`},
                    {ip:3, note:'ret'}
                ];
                return {
                    id:'', title:'üìö PIC table ‚Äî RIP+imm',
                    goal:`RAX must equal table[${idx}]`,
                    hint:'LEA RBX,[RIP+imm]; then load [RBX+RCX*8]',
                    explanation:'–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π PIC-–ø–∞—Ç—Ç–µ—Ä–Ω –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç–∞–±–ª–∏—Ü–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ .rodata —á–µ—Ä–µ–∑ RIP-relative –∞–¥—Ä–µ—Å–∞—Ü–∏—é.',
                    base, strings:['.rodata', 'RIP-relative table'],
                    disasm, cfg:linearCFG(disasm,'PIC QWORD table'),
                    trace, check:(s)=> s.regs.rax===vals[idx]
                };
            }
        },

        // === memset via REP STOS (B/Q) ===
        memset_rep_stos: {
            label:'memset (REP STOSB/STOSQ)',
            params:[
                {key:'mode', label:'mode (b|q)', def:'q'},
                {key:'len',  label:'count (elements)', def:'16'}, // bytes for B, qwords for Q
                {key:'dst',  label:'dst (hex)', def:'0x402800'},
                {key:'fill', label:'fill byte (hex, 0..ff)', def:'0x00'}
            ],
            build:(p)=>{
                const mode = (p.mode||'q').toLowerCase();
                const isQ = mode==='q';
                const cnt = Math.max(1, parseInt(p.len,10)|| (isQ?2:16));
                const dst = parseInt(p.dst,16)||0x402800;
                const fill = parseInt(p.fill,16)&0xff;
                const base=0x401000;
                // RDI=dst; RAX=value (byte expanded –¥–ª—è Q); RCX=count; rep stos[b/q]
                const fill64 = BigInt(
                    (fill) |
                    (fill<<8) | (fill<<16) | (fill<<24) |
                    (fill<<32) | (fill<<40) | (fill<<48) | (fill<<56)
                );
                const disasm=[
                    {a:base+0x00,b:'48 c7 c7 '+toImm32(dst), s:`mov rdi, ${hexs(dst)}`},
                    {a:base+0x07,b:'48 c7 c1 '+toImm32(cnt), s:`mov rcx, ${cnt}`},
                    {a:base+0x0e,b:'48 c7 c0 '+toImm32(fill), s:`mov rax, ${hexs(fill)} ; (byte)`},
                    {a:base+0x15,b: isQ ? 'f3 48 ab' : 'f3 aa', s: isQ?'rep stosq':'rep stosb'},
                    {a:base+0x18,b:'c3', s:'ret'}
                ];
                const advanced = isQ ? cnt*8 : cnt*1;
                const trace=[
                    {ip:0, regs:{rdi:BigInt(dst)}, note:`RDI=dst`},
                    {ip:1, regs:{rcx:BigInt(cnt)}, note:`RCX=count (${cnt}${isQ?' qwords':' bytes'})`},
                    {ip:2, regs:{rax:isQ?fill64:BigInt(fill)}, note:isQ?`RAX=0x${fill64.toString(16)} (replicated byte)`:`AL=${hexs(fill)}`},
                    {ip:3, regs:{rcx:0n, rdi:BigInt(dst+advanced)}, note:`rep stos${isQ?'q':'b'} ‚Üí filled ${advanced} bytes`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:`üßπ memset ‚Äî REP STOS${isQ?'Q':'B'}`,
                    goal:`RCX=0 and RDI advanced by ${advanced} bytes`,
                    hint:`RAX=fill, RCX=count, RDI=dst; rep stos${isQ?'q':'b'}`,
                    explanation:'–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –∑–∞–ª–∏–≤–∫–∞ –ø–∞–º—è—Ç–∏: –±–∞–π—Ç–æ–≤–∞—è –∏–ª–∏ 8-–±–∞–π—Ç–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —á–µ—Ä–µ–∑ REP STOS.',
                    base, strings:['memset','rep stos'],
                    disasm, cfg:linearCFG(disasm,'memset'),
                    trace, check:(s)=> s.regs.rcx===0n && s.regs.rdi===BigInt(dst+advanced)
                };
            }
        },

        // === CMOVcc ‚Äî min(a,b) –±–µ–∑ –≤–µ—Ç–≤–ª–µ–Ω–∏–π (signed) ===
        cmov_min: {
            label:'CMOVcc ‚Äî min(a,b)',
            params:[
                {key:'a', label:'a (signed int)', def:'-10'},
                {key:'b', label:'b (signed int)', def:'25'}
            ],
            build:(p)=>{
                const a = parseInt(p.a,10)|0, b=parseInt(p.b,10)|0;
                const min = (a<b?a:b);
                const base=0x401000;
                // pattern: mov rax,a; mov rbx,b; mov rdx,rax; cmp rax,rbx; cmovg rdx,rbx;  (rdx=min)
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a>>>0), s:`mov rax, ${a}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b>>>0), s:`mov rbx, ${b}`},
                    {a:base+0x0e,b:'48 89 c2', s:'mov rdx, rax'},
                    {a:base+0x11,b:'48 39 d8', s:'cmp rax, rbx'},
                    {a:base+0x14,b:'48 0f 4f d3', s:'cmovg rdx, rbx'}, // –µ—Å–ª–∏ a > b, –≤–∑—è—Ç—å b ‚Üí –º–∏–Ω–∏–º—É–º –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –≤ rdx
                    {a:base+0x18,b:'c3', s:'ret'}
                ];
                const take = (a>b); // —Ç–æ–≥–¥–∞ cmovg –≤–æ–∑—å–º—ë—Ç b
                const res = BigInt(min);
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}, note:`a=${a}`},
                    {ip:1, regs:{rbx:BigInt(b)}, note:`b=${b}`},
                    {ip:2, regs:{rdx:BigInt(a)}, note:'rdx=a'},
                    {ip:3, note:'cmp a,b ‚Üí set flags'},
                    {ip:4, regs:{rdx: take?BigInt(b):BigInt(a)}, note:`cmovg ‚Üí ${take?'take b':'keep a'} (min)`},
                    {ip:5, note:'ret'}
                ];
                return {
                    id:'', title:'ü™Ñ CMOVcc ‚Äî min(a,b)',
                    goal:`RDX must be min(a,b) = ${min}`,
                    hint:'cmp a,b; cmovg rdx,rbx ‚Üí –±–µ–∑ –≤–µ—Ç–æ–∫, –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω–æ–µ –≤—Ä–µ–º—è',
                    explanation:'–ò–¥–∏–æ–º–∞ ¬´–º–∏–Ω–∏–º—É–º –±–µ–∑ –≤–µ—Ç–≤–ª–µ–Ω–∏—è¬ª —á–µ—Ä–µ–∑ —É—Å–ª–æ–≤–Ω—ã–π –ø–µ—Ä–µ–Ω–æ—Å (CMOVcc).',
                    base, strings:['branchless min','cmovcc'],
                    disasm, cfg:linearCFG(disasm,'cmov min'),
                    trace, check:(s)=> s.regs.rdx===res
                };
            }
        },

        // === SETcc ‚Äî –ø–µ—Ä–µ–Ω–æ—Å —Ñ–ª–∞–≥–∞ –≤ –±–∞–π—Ç (ZF/SF/CF/OF) ===
        setcc_flags: {
            label:'SETcc ‚Äî flags to byte',
            params:[
                {key:'cmp_l', label:'lhs (int)', def:'5'},
                {key:'cmp_r', label:'rhs (int)', def:'5'},
                {key:'cond',  label:'cond (e/ne/l/g/a/b)', def:'e'}
            ],
            build:(p)=>{
                const a=parseInt(p.cmp_l,10)|0, b=parseInt(p.cmp_r,10)|0;
                const cond=(p.cond||'e').toLowerCase(); // e:ZF=1, ne:ZF=0, l:SF‚â†OF (signed<), g:ZF=0&&SF=OF, a:CF=0&&ZF=0 (unsigned>), b:CF=1 (unsigned<)
                const base=0x401000;
                const opcode = {
                    e:  '0f 94 c2',  // sete dl
                    ne: '0f 95 c2',  // setne dl
                    l:  '0f 9c c2',  // setl dl
                    g:  '0f 9f c2',  // setg dl
                    a:  '0f 97 c2',  // seta dl
                    b:  '0f 92 c2'   // setb dl
                }[cond] || '0f 94 c2';

                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a>>>0), s:`mov rax, ${a}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b>>>0), s:`mov rbx, ${b}`},
                    {a:base+0x0e,b:'48 39 d8', s:'cmp rax, rbx'},
                    {a:base+0x11,b: opcode, s:`set${cond} dl`},
                    {a:base+0x14,b:'48 c1 e2 00', s:'and rdx, 0xff'}, // (–Ω–µ –æ–±—è–∑.) keep DL only for display
                    {a:base+0x18,b:'c3', s:'ret'}
                ];

                // —ç–º—É–ª—è—Ü–∏—è –ª–æ–≥–∏–∫–∏:
                const signedLess = (a|0) < (b|0);
                const signedGreater = (a|0) > (b|0);
                const zf = (a===b)?1:0;
                const cf = ( (a>>>0) < (b>>>0) )?1:0; // unsigned
                const of = 0; // –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã, —Ç–∏–ø–∏—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ e/ne/a/b –∑–¥–µ—Å—å
                const sf = signedLess?1:(a===b?0:(signedGreater?0:1)); // –ø—Ä–∏–±–ª–∏–∑–∏–º
                let dl=0;
                switch(cond){
                    case 'e':  dl = zf?1:0; break;
                    case 'ne': dl = zf?0:1; break;
                    case 'l':  dl = (sf!==of)?1:0; break;
                    case 'g':  dl = (!zf && sf===of)?1:0; break;
                    case 'a':  dl = (!cf && !zf)?1:0; break; // unsigned >
                    case 'b':  dl = (cf?1:0); break;        // unsigned <
                }
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}, note:`A=${a}`},
                    {ip:1, regs:{rbx:BigInt(b)}, note:`B=${b}`},
                    {ip:2, flags:{zf, sf, of, cf}, note:`cmp ‚Üí ZF=${zf} SF=${sf} OF=${of} CF=${cf}`},
                    {ip:3, regs:{rdx:BigInt(dl)}, note:`set${cond} ‚Üí DL=${dl}`},
                    {ip:4, note:'mask to 8-bit (display)'},
                    {ip:5, note:'ret'}
                ];
                return {
                    id:'', title:`üéõÔ∏è SET${cond.toUpperCase()} ‚Äî flags‚Üíbyte`,
                    goal:`DL must be ${dl}`,
                    hint:`cmp; set${cond} dl`,
                    explanation:'SETcc –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç –±—É–ª–µ–≤–æ —É—Å–ª–æ–≤–∏–µ –∏–∑ —Ñ–ª–∞–≥–æ–≤ –≤ 8-–±–∏—Ç–æ–≤—ã–π —Ä–µ–≥–∏—Å—Ç—Ä (DL). –£–¥–æ–±–Ω–æ –¥–ª—è –±—ã—Å—Ç—Ä—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫.',
                    base, strings:['setcc','flags'],
                    disasm, cfg:linearCFG(disasm,'SETcc'),
                    trace, check:(s)=> (s.regs.rdx & 0xffn)===BigInt(dl)
                };
            }
        },

        // === PLT/GOT ‚Äî –≤—Ç–æ—Ä–æ–π –≤—ã–∑–æ–≤ (GOT —É–∂–µ –ø–∞—Ç—á–µ–Ω) ===
        plt_got_second_call: {
            label:'PLT/GOT ‚Äî second call (GOT patched)',
            params:[
                {key:'msg1',label:'first message',def:'First call via resolver'},
                {key:'msg2',label:'second message',def:'Second call direct to libc'}
            ],
            build:(p)=>{
                const base=0x401000;
                // main: call puts@plt –¥–≤–∞ —Ä–∞–∑–∞; –≤–æ –≤—Ç–æ—Ä–æ–π —Ä–∞–∑ GOT —É–∫–∞–∑—ã–≤–∞–µ—Ç —Å—Ä–∞–∑—É –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å (—Å–∏–º—É–ª–∏—Ä—É–µ–º)
                const disasm=[
                    // 1st call
                    {a:base+0x00,b:'48 c7 c7 10 20 40 00', s:'mov rdi, 0x402010'},    // msg1
                    {a:base+0x07,b:'e8 14 00 00 00', s:'call 0x401020'},              // puts@plt
                    // 2nd call
                    {a:base+0x0c,b:'48 c7 c7 30 20 40 00', s:'mov rdi, 0x402030'},    // msg2
                    {a:base+0x13,b:'e8 08 00 00 00', s:'call 0x401020'},              // puts@plt
                    {a:base+0x18,b:'c3', s:'ret'},

                    // puts@plt (—Å–∏–º—É–ª—è—Ü–∏—è ¬´—É–∂–µ –ø–æ—Å–ª–µ —Ä–µ–∑–æ–ª–≤–∞¬ª)
                    {a:base+0x20,b:'ff 25 02 2f 00 00', s:'jmp QWORD PTR [rip+0x2f02] ; GOT[puts] ‚Üí libc puts'},
                ];
                const trace=[
                    // first
                    {ip:0, regs:{rdi:0x402010n}, note:`RDI ‚Üí "${p.msg1}"`},
                    {ip:1, note:'call puts@plt ‚Üí GOT jump (already patched)'},
                    // second
                    {ip:2, regs:{rdi:0x402030n}, note:`RDI ‚Üí "${p.msg2}"`},
                    {ip:3, note:'call puts@plt ‚Üí direct to libc via GOT'},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üîó PLT/GOT ‚Äî second call',
                    goal:'Both calls go direct via GOT (no resolver)',
                    hint:'–ü–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–∑–æ–≤–∞ –¥–∏–Ω–∞–º–∏–∫ –ø—Ä–∞–≤–∏—Ç GOT –∏ PLT –ø—Ä—ã–≥–∞–µ—Ç —Å—Ä–∞–∑—É –≤ libc',
                    explanation:'–õ–µ–Ω–∏–≤–∞—è –∑–∞–≥—Ä—É–∑–∫–∞: –ø–µ—Ä–≤—ã–π –≤—ã–∑–æ–≤ —Ä–µ–∑–æ–ª–≤–∏—Ç –∞–¥—Ä–µ—Å –∏ –ø–∞—Ç—á–∏—Ç GOT; –¥–∞–ª—å–Ω–µ–π—à–∏–µ –≤—ã–∑–æ–≤—ã ‚Äî –ø—Ä—è–º–æ–π –ø—Ä—ã–∂–æ–∫.',
                    base, strings:[p.msg1, p.msg2, 'puts@plt', 'libc.so.6'],
                    disasm, cfg:callCFG('main','puts@plt'),
                    trace, check:(s)=> s.ipIndex>=4
                };
            }
        },

        // === PLT/GOT ‚Äî 3-–π –≤—ã–∑–æ–≤: —É–∂–µ –≤—Å—ë –ø—Ä–æ–ø–∞—Ç—á–µ–Ω–æ, –ø—Ä–æ—Å—Ç–æ –ø—Ä—è–º–æ–π jmp —á–µ—Ä–µ–∑ GOT ===
        plt_got_third_call: {
            label:'PLT/GOT ‚Äî 3-–π –≤—ã–∑–æ–≤ (no-op)',
            params:[
                {key:'msg1',label:'message #1',def:'Warm-up (1st)'},
                {key:'msg2',label:'message #2',def:'Follow-up (2nd)'},
                {key:'msg3',label:'message #3',def:'Third call (no resolver)'}
            ],
            build:(p)=>{
                const base=0x401000;
                const disasm=[
                    // call #1
                    {a:base+0x00,b:'48 c7 c7 10 20 40 00', s:'mov rdi, 0x402010'},
                    {a:base+0x07,b:'e8 1c 00 00 00',       s:'call 0x401028'},
                    // call #2
                    {a:base+0x0c,b:'48 c7 c7 30 20 40 00', s:'mov rdi, 0x402030'},
                    {a:base+0x13,b:'e8 10 00 00 00',       s:'call 0x401028'},
                    // call #3
                    {a:base+0x18,b:'48 c7 c7 50 20 40 00', s:'mov rdi, 0x402050'},
                    {a:base+0x1f,b:'e8 04 00 00 00',       s:'call 0x401028'},
                    {a:base+0x24,b:'c3',                   s:'ret'},

                    // puts@plt: –ø—Ä–µ–¥—Å—Ç–∞–≤–∏–º, —á—Ç–æ GOT —É–∂–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å (–ø–∞—Ç—á –±—ã–ª –Ω–∞ 1-–º –≤—ã–∑–æ–≤–µ)
                    {a:base+0x28,b:'ff 25 02 2f 00 00',    s:'jmp QWORD PTR [rip+0x2f02] ; GOT[puts] ‚Üí libc puts'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:0x402010n}, note:`"${p.msg1}"`},
                    {ip:1, note:'puts@plt ‚Üí GOT ‚Üí libc (–ø—Ä—è–º–æ)'},
                    {ip:2, regs:{rdi:0x402030n}, note:`"${p.msg2}"`},
                    {ip:3, note:'puts@plt ‚Üí GOT ‚Üí libc (–ø—Ä—è–º–æ)'},
                    {ip:4, regs:{rdi:0x402050n}, note:`"${p.msg3}"`},
                    {ip:5, note:'puts@plt ‚Üí GOT ‚Üí libc (–ø—Ä—è–º–æ)'},
                    {ip:6, note:'ret'}
                ];
                return {
                    id:'', title:'üîó PLT/GOT ‚Äî 3-–π –≤—ã–∑–æ–≤ (no-op)',
                    goal:'–í—Å–µ —Ç—Ä–∏ –≤—ã–∑–æ–≤–∞ –∏–¥—É—Ç –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ GOT (–±–µ–∑ —Ä–µ–∑–æ–ª–≤–µ—Ä–∞)',
                    hint:'–ü–æ—Å–ª–µ 1-–≥–æ –ª–µ–Ω–∏–≤–æ–≥–æ —Ä–µ–∑–æ–ª–≤–∞ GOT –ø–∞—Ç—á–µ–Ω ‚Äî –æ—Å—Ç–∞–ª—å–Ω—ã–µ –≤—ã–∑–æ–≤—ã no-op',
                    explanation:'–ó–∞–∫—Ä–µ–ø–ª—è–µ–º –∏–¥–µ—é lazy binding: –ø–æ—Å–ª–µ–¥—É—é—â–∏–µ –≤—ã–∑–æ–≤—ã ‚Äî —á–∏—Å—Ç—ã–π jmp —á–µ—Ä–µ–∑ GOT.',
                    base, strings:[p.msg1,p.msg2,p.msg3,'puts@plt','libc.so.6'],
                    disasm, cfg:callCFG('main','puts@plt'),
                    trace, check:(s)=> s.ipIndex>=6
                };
            }
        },

        // === CMOV ‚Äî signed max(a,b) –±–µ–∑ –≤–µ—Ç–≤–ª–µ–Ω–∏–π ===
        cmov_max_signed: {
            label:'CMOVcc ‚Äî signed max(a,b)',
            params:[ {key:'a',label:'a (int32)',def:'-7'}, {key:'b',label:'b (int32)',def:'12'} ],
            build:(p)=>{
                const a=(parseInt(p.a,10)|0), b=(parseInt(p.b,10)|0);
                const max=(a>b?a:b);
                const base=0x401000;
                // rdx=a; cmp a,b; cmovl rdx, rbx  ‚Üí –µ—Å–ª–∏ a<b (signed), –±–µ—Ä–µ–º b, –∏–Ω–∞—á–µ –æ—Å—Ç–∞—ë—Ç—Å—è a ‚Üí –º–∞–∫—Å–∏–º—É–º –≤ rdx
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a>>>0), s:`mov rax, ${a}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b>>>0), s:`mov rbx, ${b}`},
                    {a:base+0x0e,b:'48 89 c2',                 s:'mov rdx, rax'},
                    {a:base+0x11,b:'48 39 d8',                 s:'cmp rax, rbx'},
                    {a:base+0x14,b:'48 0f 4c d3',              s:'cmovl rdx, rbx'},
                    {a:base+0x18,b:'c3',                       s:'ret'}
                ];
                const take=(a<b);
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}, note:`a=${a}`},
                    {ip:1, regs:{rbx:BigInt(b)}, note:`b=${b}`},
                    {ip:2, regs:{rdx:BigInt(a)}, note:'rdx=a'},
                    {ip:3, note:'cmp (signed)'},
                    {ip:4, regs:{rdx:BigInt(take?b:a)}, note:`cmovl ‚Üí ${take?'take b':'keep a'} (max)`},
                    {ip:5, note:'ret'}
                ];
                return {
                    id:'', title:'ü™Ñ CMOV (signed) ‚Äî max',
                    goal:`RDX must be ${max}`,
                    hint:'cmp a,b; cmovl rdx,rbx ‚Üí –µ—Å–ª–∏ a<b, –≤–æ–∑—å–º–∏ b',
                    explanation:'Signed-–≤–∞—Ä–∏–∞–Ω—Ç –º–∞–∫—Å–∏–º—É–º–∞ –±–µ–∑ –≤–µ—Ç–æ–∫: CMOVL –∫–æ–ø–∏—Ä—É–µ—Ç b, –∫–æ–≥–¥–∞ a<b.',
                    base, strings:['cmovl','branchless max (signed)'],
                    disasm, cfg:linearCFG(disasm,'cmov signed max'),
                    trace, check:(s)=> s.regs.rdx===BigInt(max)
                };
            }
        },

        // === CMOV ‚Äî unsigned max(a,b) (–±–µ–∑ –≤–µ—Ç–æ–∫) ===
        cmov_max_unsigned: {
            label:'CMOVcc ‚Äî unsigned max(a,b)',
            params:[ {key:'a',label:'a (u32)',def:'4000000000'}, {key:'b',label:'b (u32)',def:'123456789'} ],
            build:(p)=>{
                const a=(parseInt(p.a,10)>>>0), b=(parseInt(p.b,10)>>>0);
                const max=((a>>>0)>(b>>>0)?a:b);
                const base=0x401000;
                // rdx=a; cmp a,b (unsigned); cmovb rdx, rbx  ‚Üí –µ—Å–ª–∏ a<b (unsigned), –±–µ—Ä–µ–º b ‚Üí –º–∞–∫—Å–∏–º—É–º
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a), s:`mov rax, ${a} ; a (u32)`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b), s:`mov rbx, ${b} ; b (u32)`},
                    {a:base+0x0e,b:'48 89 c2',             s:'mov rdx, rax'},
                    {a:base+0x11,b:'48 39 d8',             s:'cmp rax, rbx  ; unsigned'},
                    {a:base+0x14,b:'48 0f 42 d3',          s:'cmovb rdx, rbx'},
                    {a:base+0x18,b:'c3',                   s:'ret'}
                ];
                const take=((a>>>0)<(b>>>0));
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}, note:`a=${a} (u32)`},
                    {ip:1, regs:{rbx:BigInt(b)}, note:`b=${b} (u32)`},
                    {ip:2, regs:{rdx:BigInt(a)}, note:'rdx=a'},
                    {ip:3, note:'cmp (unsigned)'},
                    {ip:4, regs:{rdx:BigInt(take?b:a)}, note:`cmovb ‚Üí ${take?'take b':'keep a'} (max)`},
                    {ip:5, note:'ret'}
                ];
                return {
                    id:'', title:'ü™Ñ CMOV (unsigned) ‚Äî max',
                    goal:`RDX must be ${max}`,
                    hint:'cmp a,b; cmovb rdx,rbx ‚Üí –µ—Å–ª–∏ a<b (unsigned), –≤–∑—è—Ç—å b',
                    explanation:'–ë–µ–∑–≤–µ—Ç–≤–µ–≤–æ–π –º–∞–∫—Å–∏–º—É–º –¥–ª—è –±–µ–∑–∑–Ω–∞–∫–æ–≤—ã—Ö —á–∏—Å–µ–ª: CMOVB –ø–µ—Ä–µ–Ω–æ—Å–∏—Ç b –ø—Ä–∏ CF=1.',
                    base, strings:['cmovb','branchless max (unsigned)'],
                    disasm, cfg:linearCFG(disasm,'cmov unsigned max'),
                    trace, check:(s)=> s.regs.rdx===BigInt(max)
                };
            }
        },

        // === SETcc ‚Äî signed: L/LE/G/GE ===
        setcc_signed: {
            label:'SETcc ‚Äî signed (L/LE/G/GE)',
            params:[
                {key:'lhs',label:'lhs (int32)',def:'-5'},
                {key:'rhs',label:'rhs (int32)',def:'7'},
                {key:'cond',label:'cond (l|le|g|ge)',def:'le'}
            ],
            build:(p)=>{
                const a=(parseInt(p.lhs,10)|0), b=(parseInt(p.rhs,10)|0);
                const cond=(p.cond||'le').toLowerCase();
                const base=0x401000;
                const opcode = { l:'0f 9c c2', le:'0f 9e c2', g:'0f 9f c2', ge:'0f 9d c2' }[cond] || '0f 9e c2';
                // –ü—Ä–∞–≤–∏–ª–∞: L: SF!=OF; LE: (SF!=OF)||ZF; G: !ZF && SF==OF; GE: SF==OF
                const lt = (a|0) < (b|0), eq = (a|0)===(b|0), gt = (a|0)>(b|0);
                let dl=0;
                if (cond==='l')  dl = lt?1:0;
                if (cond==='le') dl = (lt||eq)?1:0;
                if (cond==='g')  dl = (gt?1:0);
                if (cond==='ge') dl = (gt||eq)?1:0;

                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a>>>0), s:`mov rax, ${a}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b>>>0), s:`mov rbx, ${b}`},
                    {a:base+0x0e,b:'48 39 d8', s:'cmp rax, rbx  ; signed'},
                    {a:base+0x11,b: opcode,    s:`set${cond} dl`},
                    {a:base+0x14,b:'c3',       s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}, note:`A=${a}`},
                    {ip:1, regs:{rbx:BigInt(b)}, note:`B=${b}`},
                    {ip:2, note:`cmp ‚Üí lt=${lt} eq=${eq} gt=${gt}`},
                    {ip:3, regs:{rdx:BigInt(dl)}, note:`set${cond} ‚Üí DL=${dl}`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:`üéöÔ∏è SET${cond.toUpperCase()} ‚Äî signed`,
                    goal:`DL must be ${dl}`,
                    hint:'L: <, LE: ‚â§, G: >, GE: ‚â• (signed)',
                    explanation:'Signed-—É—Å–ª–æ–≤–∏—è –Ω–∞ SF/OF/ZF ‚Äî –±—ã—Å—Ç—Ä—ã–µ –±—É–ª–µ–≤—ã –±–µ–∑ –≤–µ—Ç–æ–∫.',
                    base, strings:['setl/setle/setg/setge','signed compare'],
                    disasm, cfg:linearCFG(disasm,'SETcc signed'),
                    trace, check:(s)=> (s.regs.rdx & 0xffn)===BigInt(dl)
                };
            }
        },

        // === LEA ‚Äî —Å–ª–æ–∂–Ω—ã–µ –∞–¥—Ä–µ—Å–∞: [base + index*scale + imm] ===
        lea_scaled_index: {
            label:'LEA ‚Äî —Å–ª–æ–∂–Ω–∞—è –∞–¥—Ä–µ—Å–∞—Ü–∏—è',
            params:[
                {key:'base', label:'base (hex)',   def:'0x600000'},
                {key:'idx',  label:'index (hex)',  def:'0x10'},
                {key:'scale',label:'scale (1|2|4|8)', def:'4'},
                {key:'imm',  label:'imm (signed int)', def:'-32'}
            ],
            build:(p)=>{
                const baseAddr = parseInt(p.base,16)||0x600000;
                const idxVal   = parseInt(p.idx,16)||0x10;
                const scale    = Math.max(1, Math.min(8, parseInt(p.scale,10)||4));
                const imm      = parseInt(p.imm,10)||-32;
                const result   = BigInt(baseAddr + idxVal*scale + imm);
                const base=0x401000;

                // –ö–æ–¥: mov rbx,base; mov rcx,idx; lea rax,[rbx+rcx*scale+imm]; ret
                const scaleMap={1:'00',2:'40',4:'80',8:'c0'}; // —Å–∏–º–≤–æ–ª–∏–∫–∞ –¥–ª—è –∫–æ–º–º–µ–Ω—Ç–∞
                const disasm=[
                    {a:base+0x00,b:'48 c7 c3 '+toImm32(baseAddr), s:`mov rbx, ${hexs(baseAddr)} ; base`},
                    {a:base+0x07,b:'48 c7 c1 '+toImm32(idxVal),   s:`mov rcx, ${hexs(idxVal)} ; index`},
                    {a:base+0x0e,b:'48 8d 84 8b '+toImm32(imm>>>0), s:`lea rax, [rbx+rcx*${scale}+${imm}]`},
                    {a:base+0x15,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rbx:BigInt(baseAddr)}, note:`RBX=base=${hexs(baseAddr)}`},
                    {ip:1, regs:{rcx:BigInt(idxVal)},   note:`RCX=index=${hexs(idxVal)}`},
                    {ip:2, regs:{rax:result},           note:`RAX=base + index*${scale} + ${imm} = ${'0x'+result.toString(16)}`},
                    {ip:3, note:'ret'}
                ];
                return {
                    id:'', title:'üìê LEA ‚Äî [base + index*scale + imm]',
                    goal:`RAX must be ${'0x'+result.toString(16)}`,
                    hint:'LEA –Ω–µ —á–∏—Ç–∞–µ—Ç –ø–∞–º—è—Ç—å ‚Äî —Ç–æ–ª—å–∫–æ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ –∞–¥—Ä–µ—Å–∞',
                    explanation:'LEA —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –∫–∞–∫ –¥–µ—à—ë–≤—ã–π –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏–π ¬´MAC¬ª: base + index*scale + imm.',
                    base, strings:['LEA','addressing'],
                    disasm, cfg:linearCFG(disasm,'LEA complex'),
                    trace, check:(s)=> s.regs.rax===result
                };
            }
        },
        // === (a==b) && (c!=d) —á–µ—Ä–µ–∑ SETcc/AND, –±–µ–∑ –≤–µ—Ç–æ–∫ ===
        combo_eq_neq: {
            label:'Combo checks ‚Äî (a==b)&&(c!=d)',
            params:[
                {key:'a',label:'a',def:'10'},
                {key:'b',label:'b',def:'10'},
                {key:'c',label:'c',def:'5'},
                {key:'d',label:'d',def:'7'}
            ],
            build:(p)=>{
                const a=+p.a|0, b=+p.b|0, c=+p.c|0, d=+p.d|0;
                const res=((a===b)&&(c!==d))?1:0;
                const base=0x401000;
                // cmp a,b ‚Üí sete dl; cmp c,d ‚Üí setne al; and dl,al ‚Üí –≤ DL 0/1
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(a>>>0), s:`mov rax, ${a}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(b>>>0), s:`mov rbx, ${b}`},
                    {a:base+0x0e,b:'48 39 d8', s:'cmp rax, rbx'},      // ZF=1 –µ—Å–ª–∏ —Ä–∞–≤–Ω—ã
                    {a:base+0x11,b:'0f 94 c2', s:'sete dl'},           // DL = (a==b)
                    {a:base+0x14,b:'48 c7 c0 '+toImm32(c>>>0), s:`mov rax, ${c}`},
                    {a:base+0x1b,b:'48 c7 c3 '+toImm32(d>>>0), s:`mov rbx, ${d}`},
                    {a:base+0x22,b:'48 39 d8', s:'cmp rax, rbx'},      // ZF=1 –µ—Å–ª–∏ —Ä–∞–≤–Ω—ã
                    {a:base+0x25,b:'0f 95 c0', s:'setne al'},          // AL = (c!=d)
                    {a:base+0x28,b:'20 c2',    s:'and dl, al'},        // DL = DL & AL
                    {a:base+0x2a,b:'88 d0',    s:'mov al, dl'},        // –≤–µ—Ä–Ω—É—Ç—å –≤ AL
                    {a:base+0x2c,b:'c3',       s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(a)}},
                    {ip:1, regs:{rbx:BigInt(b)}},
                    {ip:2, note:'cmp a,b'},
                    {ip:3, regs:{rdx:BigInt(a===b?1:0)}, note:`DL=${a===b?1:0}`},
                    {ip:4, regs:{rax:BigInt(c)}},
                    {ip:5, regs:{rbx:BigInt(d)}},
                    {ip:6, note:'cmp c,d'},
                    {ip:7, regs:{rax:BigInt(c!==d?1:0)}, note:`AL=${c!==d?1:0}`},
                    {ip:8, regs:{rdx:BigInt(res)} , note:`DL=DL&AL=${res}`},
                    {ip:9, regs:{rax:BigInt(res)}},
                    {ip:10, note:'ret'}
                ];
                return {
                    id:'', title:'üîó Combo SETcc: (a==b)&&(c!=d)',
                    goal:`AL must be ${res}`,
                    hint:'cmp; sete dl  ‚ãÇ  setne al; and dl,al',
                    explanation:'–ö–æ–º–ø–æ–∑–∏—Ü–∏—è –±—É–ª–µ–≤—ã—Ö –±–µ–∑ –≤–µ—Ç–æ–∫: –ø–µ—Ä–µ–Ω–æ—Å–∏–º —É—Å–ª–æ–≤–∏—è —á–µ—Ä–µ–∑ SETcc, –∫–æ–º–±–∏–Ω–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ AND.',
                    base, strings:['sete','setne','and'],
                    disasm, cfg:linearCFG(disasm,'combo checks'),
                    trace, check:(s)=> (s.regs.rax & 0xffn)===BigInt(res)
                };
            }
        },

        // === –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä —Å–æ stride (–Ω–µ —Å—Ç–µ–ø–µ–Ω—å 2): IMUL + LEA ===
        lea_struct_stride: {
            label:'LEA + IMUL ‚Äî –º–∞—Å—Å–∏–≤ —Å—Ç—Ä—É–∫—Ç—É—Ä',
            params:[
                {key:'base',label:'base (hex)',def:'0x700000'},
                {key:'idx', label:'index',def:'3'},
                {key:'stride',label:'stride (bytes)',def:'24'},
                {key:'field_off',label:'field offset',def:'8'}
            ],
            build:(p)=>{
                const baseAddr=parseInt(p.base,16)||0x700000;
                const idx=+p.idx|0, stride=+p.stride|0, off=+p.field_off|0;
                const addr=BigInt(baseAddr + idx*stride + off);
                const base=0x401000;
                // rbx=base; ecx=idx; imul rcx,stride; lea rax,[rbx+rcx+off]
                const disasm=[
                    {a:base+0x00,b:'48 c7 c3 '+toImm32(baseAddr), s:`mov rbx, ${hexs(baseAddr)} ; base`},
                    {a:base+0x07,b:'48 c7 c1 '+toImm32(idx),      s:`mov rcx, ${idx} ; index`},
                    {a:base+0x0e,b:'48 69 c9 '+toImm32(stride),   s:`imul rcx, ${stride} ; idx*stride`},
                    {a:base+0x15,b:'48 8d 84 0b '+toImm32(off>>>0), s:`lea rax, [rbx+rcx+${off}]`},
                    {a:base+0x1c,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rbx:BigInt(baseAddr)}},
                    {ip:1, regs:{rcx:BigInt(idx)}},
                    {ip:2, regs:{rcx:BigInt(idx*stride)} , note:`RCX=${idx*stride}`},
                    {ip:3, regs:{rax:addr}, note:`RAX=base+idx*stride+off ‚Üí ${'0x'+addr.toString(16)}`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üì¶ Struct array ‚Äî IMUL + LEA',
                    goal:`RAX must be ${'0x'+addr.toString(16)}`,
                    hint:'stride –Ω–µ 1/2/4/8 ‚Üí IMUL, –∑–∞—Ç–µ–º LEA',
                    explanation:'–ö–æ–≥–¥–∞ —à–∞–≥ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ —Å—Ç–µ–ø–µ–Ω—å 2, –∏—Å–ø–æ–ª—å–∑—É—é—Ç IMUL index–∞, –∑–∞—Ç–µ–º LEA –¥–ª—è —Å–ª–æ–∂–µ–Ω–∏—è base+offset.',
                    base, strings:['imul','lea'],
                    disasm, cfg:linearCFG(disasm,'struct stride'),
                    trace, check:(s)=> s.regs.rax===addr
                };
            }
        },

        // === –î–µ—Ç–µ–∫—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è: add + JO/JNO (OF) ===
        overflow_detect_of: {
            label:'OF detection ‚Äî add + JO/JNO',
            params:[
                {key:'x',label:'x (int32)',def:'2147483647'},
                {key:'y',label:'y (int32)',def:'1'}
            ],
            build:(p)=>{
                const x=(+p.x|0), y=(+p.y|0);
                // x=INT_MAX, y=1 ‚Üí OF=1
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(x>>>0), s:`mov rax, ${x}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(y>>>0), s:`mov rbx, ${y}`},
                    {a:base+0x0e,b:'48 01 d8', s:'add rax, rbx'},
                    {a:base+0x11,b:'70 07',    s:'jo overflow'},
                    {a:base+0x13,b:'48 c7 c2 00 00 00 00', s:'mov rdx, 0'}, // no overflow path
                    {a:base+0x1a,b:'eb 05',    s:'jmp done'},
                    {a:base+0x1c,b:'48 c7 c2 01 00 00 00', s:'overflow: mov rdx, 1'},
                    {a:base+0x23,b:'c3',       s:'done: ret'}
                ];
                const of = ((x>0 && y>0 && (x+y|0)<0) || (x<0 && y<0 && (x+y|0)>0)) ? 1:0;
                const trace=[
                    {ip:0, regs:{rax:BigInt(x)}},
                    {ip:1, regs:{rbx:BigInt(y)}},
                    {ip:2, regs:{rax:BigInt((x+y)|0)}, flags:{of}, note:`add ‚Üí OF=${of}`},
                    {ip:3, note: of? 'JO taken':'JO not taken'},
                    ...(of ? [{ip:6, regs:{rdx:1n}}] : [{ip:4, regs:{rdx:0n}}, {ip:5}]),
                    {ip:7, note:'ret'}
                ];
                return {
                    id:'', title:'üö® Overflow detect (OF)',
                    goal:`RDX must be ${of}`,
                    hint:'add; jo overflow',
                    explanation:'–ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–Ω–∞–∫–æ–≤–æ–≥–æ —Å–ª–æ–∂–µ–Ω–∏—è –æ—Ç—Ä–∞–∂–∞–µ—Ç—Å—è –≤–æ —Ñ–ª–∞–≥–µ OF; JO —Ä–µ–∞–≥–∏—Ä—É–µ—Ç –Ω–∞ OF=1.',
                    base, strings:['OF','jo/jno'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> s.regs.rdx===BigInt(of)
                };
            }
        },

        // === 128-bit —Å–ª–æ–∂–µ–Ω–∏–µ: (RDX:RAX) += (RCX:RBX) —á–µ—Ä–µ–∑ ADD/ADC ===
        adc_sbb_128: {
            label:'128-bit add ‚Äî ADD/ADC',
            params:[
                {key:'lo_a',label:'A.low (hex)',def:'0xfffffffffffffffe'},
                {key:'hi_a',label:'A.high (hex)',def:'0x0000000000000001'},
                {key:'lo_b',label:'B.low (hex)',def:'0x2'},
                {key:'hi_b',label:'B.high (hex)',def:'0x3'}
            ],
            build:(p)=>{
                const A_lo=BigInt(parseInt(p.lo_a,16)), A_hi=BigInt(parseInt(p.hi_a,16));
                const B_lo=BigInt(parseInt(p.lo_b,16)), B_hi=BigInt(parseInt(p.hi_b,16));
                const sum_lo = (A_lo + B_lo) & 0xffffffffffffffffn;
                const carry  = (A_lo + B_lo) > 0xffffffffffffffffn ? 1n : 0n;
                const sum_hi = (A_hi + B_hi + carry) & 0xffffffffffffffffn;
                const base=0x401000;
                function toImm64(n){
                    const b=BigInt(n)&0xffffffffffffffffn;
                    const bytes=[];
                    for(let i=0;i<8;i++) bytes.push(Number((b>>(BigInt(i)*8n))&0xffn));
                    return bytes.map(x=>x.toString(16).padStart(2,'0')).join(' ');
                }
                const disasm=[
                    {a:base+0x00,b:'48 b8 '+toImm64(A_lo), s:`mov rax, ${'0x'+A_lo.toString(16)}`},
                    {a:base+0x0a,b:'48 ba '+toImm64(A_hi), s:`mov rdx, ${'0x'+A_hi.toString(16)}`},
                    {a:base+0x14,b:'48 bb '+toImm64(B_lo), s:`mov rbx, ${'0x'+B_lo.toString(16)}`},
                    {a:base+0x1e,b:'48 b9 '+toImm64(B_hi), s:`mov rcx, ${'0x'+B_hi.toString(16)}`},
                    {a:base+0x28,b:'48 01 d8', s:'add rax, rbx'},  // low
                    {a:base+0x2b,b:'48 11 ca', s:'adc rdx, rcx'},  // high + carry
                    {a:base+0x2e,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:A_lo}},
                    {ip:1, regs:{rdx:A_hi}},
                    {ip:2, regs:{rbx:B_lo}},
                    {ip:3, regs:{rcx:B_hi}},
                    {ip:4, regs:{rax:sum_lo}, flags:{cf:Number(carry)} , note:`low sum, CF=${Number(carry)}`},
                    {ip:5, regs:{rdx:sum_hi}, note:'high sum with ADC'},
                    {ip:6, note:'ret'}
                ];
                return {
                    id:'', title:'üßß 128-bit add ‚Äî ADD/ADC',
                    goal:`RDX:RAX must be ${'0x'+sum_hi.toString(16)}:${'0x'+sum_lo.toString(16)}`,
                    hint:'–°–Ω–∞—á–∞–ª–∞ —Å–∫–ª–∞–¥—ã–≤–∞–µ–º low (ADD), –∑–∞—Ç–µ–º high (ADC) —Å –ø–µ—Ä–µ–Ω–æ—Å–æ–º',
                    explanation:'–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø—Ä–∏—ë–º –º–Ω–æ–≥–æ—Ä–∞–∑—Ä—è–¥–Ω–æ–π –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∏: –ø–µ—Ä–µ–Ω–æ—Å CF –∏–∑ low-—á–∞—Å—Ç–∏ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è ADC –≤ high.',
                    base, strings:['add/adc','multi-precision'],
                    disasm, cfg:linearCFG(disasm,'128-bit add'),
                    trace, check:(s)=> s.regs.rax===sum_lo && s.regs.rdx===sum_hi
                };
            }
        },

        // === Retpoline (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –º–µ—Ö–∞–Ω–∏–∫–∏) ===
        retpoline_demo: {
            label:'Retpoline (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è)',
            params:[
                {key:'tgt',label:'indirect target (hex)',def:'0x404040'}
            ],
            build:(p)=>{
                const tgt=parseInt(p.tgt,16)||0x404040;
                const base=0x401000;
                // main: mov rbx,tgt; call thunk
                // thunk: capture –≤–∏–∞ ret-–æ–±—ã–≥—Ä—ã—à–∞; (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏) –∫—Ä—É—Ç–∏–º—Å—è –≤ –ª–æ–∫–∞–ª—å–Ω–æ–º loop, —Ä–µ–∞–ª—å–Ω–æ –ø—Ä—ã–∂–æ–∫ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ
                const disasm=[
                    {a:base+0x00,b:'48 c7 c3 '+toImm32(tgt), s:`mov rbx, ${hexs(tgt)} ; target`},
                    {a:base+0x07,b:'e8 08 00 00 00', s:'call 0x401014 ; thunk'},
                    {a:base+0x0c,b:'c3', s:'ret'},

                    // thunk:
                    {a:base+0x14,b:'f3 90',     s:'pause'},
                    {a:base+0x16,b:'0f ae e8',  s:'lfence'},
                    {a:base+0x19,b:'ff e3',     s:'jmp rbx'} // –≤ —Ä–µ–∞–ª—å–Ω–æ–º retpoline —Ç—É—Ç –±—ã–ª–æ –±—ã ¬´capture¬ª —á–µ—Ä–µ–∑ ret-—Ü–∏–∫–ª—ã; —É–ø—Ä–æ—â–∞–µ–º
                ];
                const trace=[
                    {ip:0, regs:{rbx:BigInt(tgt)}, note:'RBX = indirect target'},
                    {ip:1, note:'call thunk'},
                    {ip:3, note:'pause (mispredict safe)'},
                    {ip:4, note:'lfence'},
                    {ip:5, note:`jmp rbx ‚Üí ${hexs(tgt)} (indirect transfer without speculation)`},
                    {ip:2, note:'ret'}
                ];
                return {
                    id:'', title:'üõ°Ô∏è Retpoline (concept)',
                    goal:'–ü–æ–Ω—è—Ç—å –∏–¥–µ—é ¬´–ª–æ–≤—É—à–∫–∏¬ª –¥–ª—è —Å–ø–µ–∫—É–ª—è—Ü–∏–∏ –ø–µ—Ä–µ–¥ –Ω–µ–ø—Ä—è–º—ã–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º',
                    hint:'pause/lfence + ¬´–ø–µ—Ç–ª—è¬ª –≤–º–µ—Å—Ç–æ –ø—Ä—è–º–æ–≥–æ jmp [mem]',
                    explanation:'–°–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è –≤–µ—Ä—Å–∏—è retpoline: —É—Å—Ç—Ä–∞–Ω—è–µ–º –Ω–µ–∂–µ–ª–∞—Ç–µ–ª—å–Ω—É—é —Å–ø–µ–∫—É–ª—è—Ü–∏—é –Ω–∞ –Ω–µ–ø—Ä—è–º—ã—Ö –ø–µ—Ä–µ—Ö–æ–¥–∞—Ö.',
                    base, strings:['retpoline','lfence','pause'],
                    disasm, cfg:callCFG('main','thunk'),
                    trace, check:(s)=> s.ipIndex>=5
                };
            }
        },

        // === Tail call: A –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è ‚Äî jmp –≤ B ===
        tail_call_opt: {
            label:'Tail call optimization (jmp)',
            params:[
                {key:'x',label:'x',def:'7'},
                {key:'y',label:'y',def:'35'}
            ],
            build:(p)=>{
                const x=+p.x|0, y=+p.y|0, sum=x+y;
                const base=0x401000;
                // A: –≥–æ—Ç–æ–≤–∏—Ç –∞—Ä–≥, –≤–º–µ—Å—Ç–æ call B/ret ‚Äî tail jmp B
                const disasm=[
                    // A:
                    {a:base+0x00,b:'48 c7 c7 '+toImm32(x>>>0), s:`mov rdi, ${x}`},
                    {a:base+0x07,b:'48 c7 c6 '+toImm32(y>>>0), s:`mov rsi, ${y}`},
                    {a:base+0x0e,b:'ff 25 0c 00 00 00',        s:'jmp QWORD PTR [rip+0xc] ; ‚Üí B'},
                    {a:base+0x14,b:'c3', s:'ret'}, // –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º–æ

                    // B:
                    {a:base+0x1a,b:'55', s:'push rbp'},
                    {a:base+0x1b,b:'48 89 e5', s:'mov rbp, rsp'},
                    {a:base+0x1e,b:'48 89 f8', s:'mov rax, rdi'},
                    {a:base+0x21,b:'48 01 f0', s:'add rax, rsi'},
                    {a:base+0x24,b:'5d', s:'pop rbp'},
                    {a:base+0x25,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:BigInt(x)}},
                    {ip:1, regs:{rsi:BigInt(y)}},
                    {ip:2, note:'tail jmp ‚Üí B (–±–µ–∑ –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ A)'},
                    {ip:6, regs:{rax:BigInt(sum)}, note:`B: RAX = x+y = ${sum}`},
                    {ip:9, note:'ret (–∫ –≤—ã–∑–≤–∞–≤—à–µ–º—É A)'}
                ];
                return {
                    id:'', title:'üèÅ Tail call ‚Äî jmp –≤–º–µ—Å—Ç–æ call/ret',
                    goal:`RAX must be ${sum}`,
                    hint:'–≤ —Ö–≤–æ—Å—Ç–µ A –¥–µ–ª–∞–µ–º jmp B: —Ñ—Ä–µ–π–º A –Ω–µ –æ—Å—Ç–∞—ë—Ç—Å—è',
                    explanation:'–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è —Ö–≤–æ—Å—Ç–æ–≤—ã—Ö –≤—ã–∑–æ–≤–æ–≤: –ø–µ—Ä–µ—Ö–æ–¥ –≤ B —á–µ—Ä–µ–∑ jmp, —á—Ç–æ –∏–∑–±–µ–≥–∞–µ—Ç –ª–∏—à–Ω–µ–≥–æ –∫–∞–¥—Ä–∞ —Å—Ç–µ–∫–∞.',
                    base, strings:['tail call','jmp'],
                    disasm, cfg:callCFG('A','B'),
                    trace, check:(s)=> s.regs.rax===BigInt(sum)
                };
            }
        },

        // === 128-bit –≤—ã—á–∏—Ç–∞–Ω–∏–µ: (RDX:RAX) -= (RCX:RBX) —á–µ—Ä–µ–∑ SUB/SBB ===
        sbb_128_sub: {
            label:'128-bit sub ‚Äî SUB/SBB (borrow)',
            params:[
                {key:'lo_a',label:'A.low (hex)',def:'0x0000000000000001'},
                {key:'hi_a',label:'A.high (hex)',def:'0x0000000000000002'},
                {key:'lo_b',label:'B.low (hex)',def:'0x0000000000000003'},
                {key:'hi_b',label:'B.high (hex)',def:'0x0000000000000001'}
            ],
            build:(p)=>{
                const A_lo=BigInt(parseInt(p.lo_a,16)), A_hi=BigInt(parseInt(p.hi_a,16));
                const B_lo=BigInt(parseInt(p.lo_b,16)), B_hi=BigInt(parseInt(p.hi_b,16));
                const under = (A_lo < B_lo) ? 1n : 0n;
                const diff_lo = (A_lo - B_lo) & 0xffffffffffffffffn;
                const diff_hi = (A_hi - B_hi - under) & 0xffffffffffffffffn;
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 b8 '+toImm64(A_lo), s:`mov rax, ${'0x'+A_lo.toString(16)}`},
                    {a:base+0x0a,b:'48 ba '+toImm64(A_hi), s:`mov rdx, ${'0x'+A_hi.toString(16)}`},
                    {a:base+0x14,b:'48 bb '+toImm64(B_lo), s:`mov rbx, ${'0x'+B_lo.toString(16)}`},
                    {a:base+0x1e,b:'48 b9 '+toImm64(B_hi), s:`mov rcx, ${'0x'+B_hi.toString(16)}`},
                    {a:base+0x28,b:'48 29 d8', s:'sub rax, rbx'}, // low
                    {a:base+0x2b,b:'48 19 ca', s:'sbb rdx, rcx'}, // high - borrow
                    {a:base+0x2e,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:A_lo}},
                    {ip:1, regs:{rdx:A_hi}},
                    {ip:2, regs:{rbx:B_lo}},
                    {ip:3, regs:{rcx:B_hi}},
                    {ip:4, regs:{rax:diff_lo}, flags:{cf:Number(under)}, note:`low diff, CF(borrow)=${Number(under)}`},
                    {ip:5, regs:{rdx:diff_hi}, note:'high diff with SBB'},
                    {ip:6, note:'ret'}
                ];
                return {
                    id:'', title:'üß± 128-bit sub ‚Äî SUB/SBB',
                    goal:`RDX:RAX == ${'0x'+diff_hi.toString(16)}:${'0x'+diff_lo.toString(16)}`,
                    hint:'–°–Ω–∞—á–∞–ª–∞ low (SUB), –∑–∞—Ç–µ–º high (SBB) —É—á–∏—Ç—ã–≤–∞—è –∑–∞–π–º CF',
                    explanation:'–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø—Ä–∏—ë–º –º–Ω–æ–≥–æ—Å–ª–æ–≤–Ω–æ–≥–æ –≤—ã—á–∏—Ç–∞–Ω–∏—è: SBB —É—á–∏—Ç—ã–≤–∞–µ—Ç ¬´–∑–∞–Ω–∏–º¬ª –∏–∑ –º–ª–∞–¥—à–µ–π —á–∞—Å—Ç–∏.',
                    base, strings:['sub/sbb','multi-precision'],
                    disasm, cfg:linearCFG(disasm,'128-bit sub'),
                    trace, check:(s)=> s.regs.rax===diff_lo && s.regs.rdx===diff_hi
                };
            }
        },

        // === –î–∏–∞–ø–∞–∑–æ–Ω: lo ‚â§ x ‚â§ hi (–±–µ–∑ –≤–µ—Ç–æ–∫) ===
        range_check_inclusive: {
            label:'Range check: lo ‚â§ x ‚â§ hi (SETcc)',
            params:[
                {key:'x', label:'x',  def:'42'},
                {key:'lo',label:'lo', def:'40'},
                {key:'hi',label:'hi', def:'50'},
                {key:'signed',label:'signed? (0|1)',def:'1'}
            ],
            build:(p)=>{
                const x=+p.x|0, lo=+p.lo|0, hi=+p.hi|0, isSigned=+p.signed?1:0;
                const inRange = isSigned
                    ? ((x|0) >= (lo|0) && (x|0) <= (hi|0)) ? 1 : 0
                    : (((x>>>0) >= (lo>>>0)) && ((x>>>0) <= (hi>>>0))) ? 1 : 0;
                const base=0x401000;
                // idea: (x>=lo) & (x<=hi) —á–µ—Ä–µ–∑ –¥–≤–∞ SETcc –∏ AND
                // signed: setge/setle ; unsigned: setae/setbe
                const op_ge = isSigned ? '0f 9d c2' : '0f 93 c2'; // setge dl / setae dl
                const op_le = isSigned ? '0f 9e c0' : '0f 96 c0'; // setle al / setbe al
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(x>>>0),  s:`mov rax, ${x} ; x`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(lo>>>0), s:`mov rbx, ${lo} ; lo`},
                    {a:base+0x0e,b:'48 39 d8',                  s:'cmp rax, rbx'},
                    {a:base+0x11,b: op_ge,                       s: isSigned?'setge dl':'setae dl'}, // DL = x>=lo
                    {a:base+0x14,b:'48 c7 c3 '+toImm32(hi>>>0), s:`mov rbx, ${hi} ; hi`},
                    {a:base+0x1b,b:'48 39 d8',                  s:'cmp rax, rbx'},
                    {a:base+0x1e,b: op_le,                       s: isSigned?'setle al':'setbe al'}, // AL = x<=hi
                    {a:base+0x21,b:'20 c2',                     s:'and dl, al'}, // DL = inRange
                    {a:base+0x23,b:'88 d0',                     s:'mov al, dl'},
                    {a:base+0x25,b:'c3',                         s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(x)}},
                    {ip:1, regs:{rbx:BigInt(lo)}},
                    {ip:2, note:'cmp x,lo'},
                    {ip:3, regs:{rdx:BigInt((isSigned? (x>=lo):( (x>>>0)>=(lo>>>0) ))?1:0)}},
                    {ip:4, regs:{rbx:BigInt(hi)}},
                    {ip:5, note:'cmp x,hi'},
                    {ip:6, regs:{rax:BigInt((isSigned? (x<=hi):( (x>>>0)<=(hi>>>0) ))?1:0)}},
                    {ip:7, regs:{rdx:BigInt(inRange)}, note:`DL=AND=${inRange}`},
                    {ip:8, regs:{rax:BigInt(inRange)}},
                    {ip:9, note:'ret'}
                ];
                return {
                    id:'', title:`üéØ Range check ${isSigned?'(signed)':'(unsigned)'}: lo ‚â§ x ‚â§ hi`,
                    goal:`AL must be ${inRange}`,
                    hint:`cmp; ${isSigned?'setge':'setae'} ‚ãÇ ${isSigned?'setle':'setbe'} ‚Üí AND`,
                    explanation:'–î–∏–∞–ø–∞–∑–æ–Ω –±–µ–∑ –≤–µ—Ç–æ–∫: –¥–≤–∞ SETcc –∏ AND –¥–∞—é—Ç –±—É–ª–µ–≤ –∏—Ç–æ–≥.',
                    base, strings:['range','setcc'],
                    disasm, cfg:linearCFG(disasm,'range check'),
                    trace, check:(s)=> (s.regs.rax & 0xffn)===BigInt(inRange)
                };
            }
        },

        // === Saturating add (int8): clamp –∫ INT8_MIN/INT8_MAX –ø—Ä–∏ OF ===
        saturating_add_i8: {
            label:'Saturating add (int8)',
            params:[
                {key:'a',label:'a (int8)',def:'120'},
                {key:'b',label:'b (int8)',def:'20'}
            ],
            build:(p)=>{
                // –ø—Ä–∏–≤–æ–¥–∏–º –∫ int8:
                const toI8 = v => ((v<<24)>>24)|0;
                const clampI8 = v => Math.max(-128, Math.min(127, v|0));
                const a = toI8(+p.a|0), b = toI8(+p.b|0);
                const sum = a + b;
                const of = ( (a>0 && b>0 && sum>127) || (a<0 && b<0 && sum<-128) ) ? 1 : 0;
                const sat = of ? (a>0 ? 127 : -128) : toI8(sum);
                const base=0x401000;
                // —ç–º—É–ª—è—Ü–∏—è: movsx eax,al; movsx ebx,bl; add al, bl; jo of; mov al,clamped
                const disasm=[
                    {a:base+0x00,b:'b0 '+((a&0xff).toString(16)).padStart(2,'0'), s:`mov al, ${a} (int8)`},
                    {a:base+0x02,b:'b3 '+((b&0xff).toString(16)).padStart(2,'0'), s:`mov bl, ${b} (int8)`},
                    {a:base+0x04,b:'00 d8', s:'add al, bl'},
                    {a:base+0x06,b:'70 07', s:'jo clamp'}, // if OF
                    {a:base+0x08,b:'48 0f b6 c0', s:'movzx rax, al ; OK path'},
                    {a:base+0x0c,b:'c3', s:'ret'},
                    {a:base+0x0d,b:'b0 '+((sat&0xff).toString(16)).padStart(2,'0'), s:`clamp: mov al, ${sat}`},
                    {a:base+0x0f,b:'48 0f b6 c0', s:'movzx rax, al'},
                    {a:base+0x13,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, note:`AL=a=${a}`},
                    {ip:1, note:`BL=b=${b}`},
                    {ip:2, flags:{of}, note:`add ‚Üí OF=${of}`},
                    ...(of
                        ? [{ip:6, note:'clamp path'}, {ip:7, regs:{rax:BigInt(sat & 0xff)}}, {ip:8, note:'ret'}]
                        : [{ip:4, regs:{rax:BigInt((toI8(sum)) & 0xff)}}, {ip:5, note:'ret'}]
                    )
                ];
                return {
                    id:'', title:'üßØ Saturating add (int8)',
                    goal:`RAX (zero-extended AL) == ${sat & 0xff}`,
                    hint:'add; jo ‚Üí –∑–∞–∂–∏–º–∞–µ–º –∫ ¬±128/127',
                    explanation:'–ù–∞—Å—ã—â–∞—é—â–∞—è –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞: –ø—Ä–∏ OF —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–∂–∏–º–∞–µ—Ç—Å—è –∫ INT8_MIN/INT8_MAX.',
                    base, strings:['saturating','jo'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> (s.regs.rax & 0xffn)===BigInt(sat & 0xff)
                };
            }
        },

        // === PLT/GOT ‚Äî –ø–æ–ª–Ω—ã–π lazy-resolve —Å—Ü–µ–Ω–∞—Ä–∏–π: 1-–π (resolver) ‚Üí 2-–π/3-–π (–ø—Ä—è–º–æ) ===
        plt_got_lazy_full: {
            label:'PLT/GOT ‚Äî lazy resolve (1‚Üí2‚Üí3)',
            params:[
                {key:'m1',label:'msg #1',def:'First ‚Äî via resolver'},
                {key:'m2',label:'msg #2',def:'Second ‚Äî GOT patched'},
                {key:'m3',label:'msg #3',def:'Third ‚Äî direct jump'}
            ],
            build:(p)=>{
                const base=0x401000;
                // main –¥–µ–ª–∞–µ—Ç —Ç—Ä–∏ –≤—ã–∑–æ–≤–∞ puts@plt; plt-—Å—Ç–∞–± –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π jmp [GOT]; push rel.index; jmp resolver
                const disasm=[
                    // main
                    {a:base+0x00,b:'48 c7 c7 10 20 40 00', s:'mov rdi, 0x402010'},
                    {a:base+0x07,b:'e8 1d 00 00 00',       s:'call 0x401029 ; puts@plt'},
                    {a:base+0x0c,b:'48 c7 c7 30 20 40 00', s:'mov rdi, 0x402030'},
                    {a:base+0x13,b:'e8 11 00 00 00',       s:'call 0x401029 ; puts@plt'},
                    {a:base+0x18,b:'48 c7 c7 50 20 40 00', s:'mov rdi, 0x402050'},
                    {a:base+0x1f,b:'e8 05 00 00 00',       s:'call 0x401029 ; puts@plt'},
                    {a:base+0x24,b:'c3',                   s:'ret'},

                    // puts@plt
                    {a:base+0x29,b:'ff 25 02 2f 00 00', s:'jmp QWORD PTR [rip+0x2f02] ; GOT[puts]'},
                    {a:base+0x2f,b:'68 00 00 00 00',    s:'push 0x0       ; reloc index'},
                    {a:base+0x34,b:'e9 c7 ff ff ff',    s:'jmp 0x401000   ; jmp to resolver (simulated back to main)'}
                ];
                // –¢—Ä–∞—Å—Å–∞ –æ–±—ä—è—Å–Ω—è–µ—Ç —ç—Ç–∞–ø—ã: 1-–π —Ä–∞–∑ ‚Äî —Ä–µ–∑–æ–ª–≤–µ—Ä, GOT –ø–∞—Ç—á–∏—Ç—Å—è; 2-–π/3-–π ‚Äî –ø—Ä—è–º—ã–µ –ø—Ä—ã–∂–∫–∏
                const trace=[
                    {ip:0, regs:{rdi:0x402010n}, note:`"${p.m1}"`},
                    {ip:1, note:'puts@plt ‚Üí [GOT] (–ø–æ–∫–∞ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ resolver)'},
                    {ip:8, note:'PLT: jmp [GOT] ‚Üí resolver, push rel.index, jmp resolver'},
                    {ip:1, note:'(–ø–æ—Å–ª–µ —Ä–µ–∑–æ–ª–≤–∞) GOT patched to libc puts'},
                    {ip:2, regs:{rdi:0x402030n}, note:`"${p.m2}"`},
                    {ip:3, note:'puts@plt ‚Üí GOT ‚Üí libc puts (–ø—Ä—è–º–æ)'},
                    {ip:4, regs:{rdi:0x402050n}, note:`"${p.m3}"`},
                    {ip:5, note:'puts@plt ‚Üí GOT ‚Üí libc puts (–ø—Ä—è–º–æ)'},
                    {ip:6, note:'ret'}
                ];
                return {
                    id:'', title:'üîó PLT/GOT ‚Äî lazy resolve (full)',
                    goal:'–í—Ç–æ—Ä–æ–π –∏ —Ç—Ä–µ—Ç–∏–π –≤—ã–∑–æ–≤—ã –∏–¥—É—Ç –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ GOT',
                    hint:'1-–π –≤—ã–∑–æ–≤ —Ä–µ–∑–æ–ª–≤–∏—Ç —Å–∏–º–≤–æ–ª, –ø–∞—Ç—á–∏—Ç GOT; –¥–∞–ª—å—à–µ ‚Äî –ø—Ä—è–º—ã–µ –ø—Ä—ã–∂–∫–∏',
                    explanation:'–ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π PLT-—Å—Ç–∞–±: jmp [GOT]; push index; jmp resolver. –ü–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –≤—ã–∑–æ–≤–∞ GOT —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ –Ω–∞—Å—Ç–æ—è—â–∏–π –∞–¥—Ä–µ—Å.',
                    base, strings:[p.m1,p.m2,p.m3,'puts@plt','resolver','libc.so.6'],
                    disasm, cfg:callCFG('main','puts@plt'),
                    trace, check:(s)=> s.ipIndex>=6
                };
            }
        },
        // === Bitpack extract: (x >> shift) & mask  ‚Äî –±–∞–∑–æ–≤–∞—è —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ –ø–æ–ª–µ–π ===
        bitpack_extract_lea: {
            label:'Bitpack extract ‚Äî (x>>shift)&mask',
            params:[
                {key:'x',     label:'x (u32)',   def:'305419896'},   // 0x12345678
                {key:'shift', label:'shift',     def:'12'},
                {key:'mask',  label:'mask (hex)',def:'0xff'}
            ],
            build:(p)=>{
                const x=(parseInt(p.x,10)>>>0);
                const sh=+p.shift|0;
                const mask=parseInt(p.mask,16)>>>0;
                const out = ((x>>>sh) & mask)>>>0;
                const base=0x401000;
                // rax=x; shr rax,sh; and rax,mask; ret
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(x), s:`mov rax, ${x} ; x`},
                    {a:base+0x07,b:'48 c1 e8 '+(sh&0xff).toString(16).padStart(2,'0'), s:`shr rax, ${sh}`},
                    {a:base+0x0b,b:'48 25 '+toImm32(mask), s:`and rax, ${'0x'+mask.toString(16)}`},
                    {a:base+0x10,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(x)}},
                    {ip:1, regs:{rax:BigInt(x>>>sh)}, note:`rax >>= ${sh}`},
                    {ip:2, regs:{rax:BigInt(out)},    note:`rax &= mask ‚Üí ${out}`},
                    {ip:3, note:'ret'}
                ];
                return {
                    id:'', title:'üß© Bitpack extract ‚Äî shift & mask',
                    goal:`RAX must be ${out}`,
                    hint:'shr + and ‚Äî –±–∞–∑–æ–≤—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –ø–æ–ª—è –∏–∑ –±–∏—Ç–ø–∞–∫–∞',
                    explanation:'–ò–∑–≤–ª–µ–∫–∞–µ–º –ø–æ–ª–µ (x>>shift)&mask ‚Äî –æ—Å–Ω–æ–≤–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ packed-—Å—Ç—Ä—É–∫—Ç—É—Ä.',
                    base, strings:['bitpack','shr/and'],
                    disasm, cfg:linearCFG(disasm,'bit extract'),
                    trace, check:(s)=> Number(s.regs.rax)===out
                };
            }
        },

        // === Saturating sub (int8): –∑–∞–∂–∏–º –∫ [-128,127] –ø—Ä–∏ OF ===
        saturating_sub_i8: {
            label:'Saturating sub (int8)',
            params:[ {key:'a',label:'a (int8)',def:'-120'}, {key:'b',label:'b (int8)',def:'20'} ],
            build:(p)=>{
                const toI8 = v => ((v<<24)>>24)|0;
                const clampI8 = v => Math.max(-128, Math.min(127, v|0));
                const a=toI8(+p.a|0), b=toI8(+p.b|0);
                const diff = a - b;
                // overflow –¥–ª—è sub: (a>=0 && b<0 && diff< -128) || (a<0 && b>=0 && diff>127)
                const of = ((a>=0 && b<0 && diff<-128) || (a<0 && b>=0 && diff>127)) ? 1 : 0;
                const sat = of ? (a>=0 ? 127 : -128) : toI8(diff);
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'b0 '+((a&0xff).toString(16)).padStart(2,'0'), s:`mov al, ${a}`},
                    {a:base+0x02,b:'b3 '+((b&0xff).toString(16)).padStart(2,'0'), s:`mov bl, ${b}`},
                    {a:base+0x04,b:'28 d8', s:'sub al, bl'},
                    {a:base+0x06,b:'70 07', s:'jo clamp'},
                    {a:base+0x08,b:'48 0f b6 c0', s:'movzx rax, al'},
                    {a:base+0x0c,b:'c3', s:'ret'},
                    {a:base+0x0d,b:'b0 '+((sat&0xff).toString(16)).padStart(2,'0'), s:`clamp: mov al, ${sat}`},
                    {a:base+0x0f,b:'48 0f b6 c0', s:'movzx rax, al'},
                    {a:base+0x13,b:'c3', s:'ret'}
                ];
                const trace = of
                    ? [{ip:0},{ip:1},{ip:2,flags:{of},note:`sub ‚Üí OF=${of}`},{ip:6},{ip:7,regs:{rax:BigInt(sat&0xff)}},{ip:8}]
                    : [{ip:0},{ip:1},{ip:2,flags:{of},note:`sub ‚Üí OF=${of}`},{ip:4,regs:{rax:BigInt(toI8(diff)&0xff)}},{ip:5}];
                return {
                    id:'', title:'üßØ Saturating sub (int8)',
                    goal:`RAX (zero-extended AL) == ${(sat & 0xff)}`,
                    hint:'sub; jo ‚Üí –∑–∞–∂–∏–º –∫ ¬±128/127',
                    explanation:'Saturating sub –¥–ª—è int8: –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç ¬´–ø—Ä–∏–ª–∏–ø–∞–µ—Ç¬ª –∫ –≥—Ä–∞–Ω–∏—Ü–∞–º –¥–∏–∞–ø–∞–∑–æ–Ω–∞.',
                    base, strings:['saturating','jo','sub'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> (s.regs.rax & 0xffn)===BigInt(sat & 0xff)
                };
            }
        },

        // === Bitcount ‚Äî CLZ/CTZ/POPCNT (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è) ===
        bitcount_clz_ctz_popcnt: {
            label:'Bitcount ‚Äî CLZ/CTZ/POPCNT (—Å–∏–º–≤.)',
            params:[ {key:'x',label:'x (u32)',def:'305419896'} /* 0x12345678 */ ],
            build:(p)=>{
                const x=(parseInt(p.x,10)>>>0);
                const clz = Math.clz32(x); // 0..32
                const ctz = (x===0)?32:((n)=>{let c=0; let v=n>>>0; while((v&1)===0){c++; v>>>=1;} return c;})(x);
                const popcnt = ((n)=>{n=n>>>0; let c=0; while(n){n&=n-1; c++;} return c;})(x);
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(x), s:`mov rax, ${x} ; x`},
                    {a:base+0x07,b:'0f bd c0', s:'bsr eax, eax  ; (—Å–∏–º–≤–æ–ª–∏—á.)'},
                    {a:base+0x0a,b:'0f bc c8', s:'bsf ecx, eax  ; (—Å–∏–º–≤–æ–ª–∏—á.)'},
                    {a:base+0x0d,b:'f3 0f b8 d0', s:'popcnt edx, eax  ; (—Å–∏–º–≤–æ–ª–∏—á.)'},
                    {a:base+0x12,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(x)}, note:`x=0x${x.toString(16)}`},
                    {ip:1, regs:{rax:BigInt(31 - (clz|0))}, note:`BSR ‚Üí index —Å—Ç–∞—Ä—à–µ–≥–æ 1-–±–∏—Ç–∞ (—Å–∏–º–≤.)`},
                    {ip:2, regs:{rcx:BigInt(ctz)}, note:`BSF ‚Üí CTZ=${ctz} (—Å–∏–º–≤.)`},
                    {ip:3, regs:{rdx:BigInt(popcnt)}, note:`POPCNT=${popcnt} (—Å–∏–º–≤.)`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üßÆ Bitcount: CLZ/CTZ/POPCNT',
                    goal:`RCX=${ctz}, RDX=${popcnt} (—Å–∏–º–≤.), –∞ CLZ=${clz}`,
                    hint:'–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∏–º–≤–æ–ª–∏–∫—É: —Å—á–∏—Ç–∞–µ–º –Ω–∞ —Å—Ç–æ—Ä–æ–Ω–µ –¥–≤–∏–∂–∫–∞, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–¥–∏–æ–º—É –≤ –¥–∏–∑–∞—Å–º–µ',
                    explanation:'BSR/BSF/POPCNT –∫–∞–∫ –∏–¥–∏–æ–º—ã. –í —Å–∏–º—É–ª—è—Ü–∏–∏ –≤—ã—á–∏—Å–ª—è–µ–º CLZ/CTZ/POPCNT —Ç–æ—á–Ω–æ, –∞ –≤ –¥–∏–∑–∞—Å–º–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω.',
                    base, strings:['bsr','bsf','popcnt'],
                    disasm, cfg:linearCFG(disasm,'bitcount'),
                    trace, check:(s)=> s.regs.rcx===BigInt(ctz) && s.regs.rdx===BigInt(popcnt)
                };
            }
        },

        // === BMI2 ‚Äî PEXT/ PDEP (—Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏) ===
        bmi2_pext_pdep: {
            label:'BMI2 ‚Äî PEXT/PDEP (—Å–∏–º–≤.)',
            params:[
                {key:'src', label:'src (u32 hex)', def:'0xdeadbeef'},
                {key:'msk', label:'mask (u32 hex)', def:'0x0f0f00f0'}
            ],
            build:(p)=>{
                const src=(parseInt(p.src,16)>>>0), m=(parseInt(p.msk,16)>>>0);
                const pext = ((s,mask)=>{ let out=0, bit=0; for(let i=0;i<32;i++){ if(mask>>>i & 1){ if(s>>>i & 1) out|=(1<<bit); bit++; } } return out>>>0; })(src,m);
                const pdep = ((s,mask)=>{ let out=0, bit=0; for(let i=0;i<32;i++){ if(mask>>>i & 1){ if(s>>>bit & 1) out|=(1<<i); bit++; } } return out>>>0; })(pext,m);
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c0 '+toImm32(src), s:`mov rax, ${'0x'+src.toString(16)}`},
                    {a:base+0x07,b:'48 c7 c3 '+toImm32(m),   s:`mov rbx, ${'0x'+m.toString(16)} ; mask`},
                    {a:base+0x0e,b:'0f 38 f5 c3', s:'pext eax, ebx  ; (—Å–∏–º–≤.)'},
                    {a:base+0x12,b:'0f 38 f4 c3', s:'pdep eax, ebx  ; (—Å–∏–º–≤.)'},
                    {a:base+0x16,b:'c3', s:'ret'}
                ];
                const trace=[
                    {ip:0, regs:{rax:BigInt(src)}},
                    {ip:1, regs:{rbx:BigInt(m)}},
                    {ip:2, regs:{rax:BigInt(pext)}, note:`PEXT(src,mask) = 0x${pext.toString(16)}`},
                    {ip:3, regs:{rax:BigInt(pdep)}, note:`PDEP(PEXT,mask) = 0x${pdep.toString(16)}`},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üß© BMI2 ‚Äî PEXT/PDEP (symbolic)',
                    goal:`RAX == 0x${pdep.toString(16)} –ø–æ—Å–ª–µ PDEP`,
                    hint:'PEXT –∏–∑–≤–ª–µ–∫–∞–µ—Ç –±–∏—Ç—ã –ø–æ –º–∞—Å–∫–µ –ø–ª–æ—Ç–Ω–æ; PDEP —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –æ–±—Ä–∞—Ç–Ω–æ',
                    explanation:'–°–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∞—è —Å–∏–º—É–ª—è—Ü–∏—è PEXT/PDEP –¥–∞—ë—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ —á–∏—Å–ª–∞, –¥–∏–∑–∞—Å–º –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–∞–º—É –∏–¥–∏–æ–º—É BMI2.',
                    base, strings:['pext','pdep','bmi2'],
                    disasm, cfg:linearCFG(disasm,'bmi2 pext/pdep'),
                    trace, check:(s)=> Number(s.regs.rax)===pdep
                };
            }
        },

        // === memcpy: SSE movdqu (>=16) vs rep movsb (<16) ‚Äî –≤–µ—Ç–≤–ª–µ–Ω–∏–µ –ø–æ —Ä–∞–∑–º–µ—Ä—É ===
        memcpy_sse_vs_rep: {
            label:'memcpy: SSE movdqu vs rep movsb',
            params:[
                {key:'n', label:'size (bytes)', def:'40'},
                {key:'src',label:'src (hex)', def:'0x500000'},
                {key:'dst',label:'dst (hex)', def:'0x600000'}
            ],
            build:(p)=>{
                const n=Math.max(0, +p.n|0);
                const src=parseInt(p.src,16)||0x500000;
                const dst=parseInt(p.dst,16)||0x600000;
                const base=0x401000;
                const blocks = Math.floor(n/16), tail = n%16;
                const disasm=[
                    {a:base+0x00,b:'48 c7 c6 '+toImm32(src), s:`mov rsi, ${hexs(src)} ; src`},
                    {a:base+0x07,b:'48 c7 c7 '+toImm32(dst), s:`mov rdi, ${hexs(dst)} ; dst`},
                    {a:base+0x0e,b:'48 c7 c1 '+toImm32(n),   s:`mov rcx, ${n} ; size`},
                    {a:base+0x15,b:'48 83 f9 10', s:'cmp rcx, 0x10'},
                    {a:base+0x19,b:'72 12',       s:'jb .tiny'},
                    // SSE path (—Å–∏–º–≤–æ–ª–∏–∫–∞ –±–ª–æ–∫–∞–º–∏ –ø–æ 16)
                    {a:base+0x1b,b:'66 0f 6f 06', s:'movdqu xmm0, [rsi]'},
                    {a:base+0x1f,b:'66 0f 7f 07', s:'movdqu [rdi], xmm0'},
                    {a:base+0x23,b:'48 83 ee 10', s:'sub rsi, -0x10 ; rsi+=16'},
                    {a:base+0x27,b:'48 83 ef 10', s:'sub rdi, -0x10 ; rdi+=16'},
                    {a:base+0x2b,b:'48 81 e9 10 00 00 00', s:'sub rcx, 0x10'},
                    {a:base+0x32,b:'75 e7', s:'jnz 0x40101b'},
                    {a:base+0x34,b:'eb 08', s:'jmp .tail'},
                    // tiny path
                    {a:base+0x36,b:'f3 a4', s:'.tiny: rep movsb'},
                    // tail (—Å–∏–º–≤–æ–ª–∏–∫–∞: rep movsb –Ω–∞ –æ—Å—Ç–∞—Ç–æ–∫)
                    {a:base+0x38,b:'f3 a4', s:'.tail: rep movsb'},
                    {a:base+0x3a,b:'c3', s:'ret'}
                ];
                const afterRSI = src + n;
                const afterRDI = dst + n;
                const trace=[
                    {ip:0, regs:{rsi:BigInt(src)}},
                    {ip:1, regs:{rdi:BigInt(dst)}},
                    {ip:2, regs:{rcx:BigInt(n)}},
                    {ip:3, note:'cmp size,16'},
                    ...(n<16
                        ? [{ip:6, note:'tiny: rep movsb (n<16)'}, {ip:8, regs:{rsi:BigInt(afterRSI), rdi:BigInt(afterRDI), rcx:0n}}, {ip:9}]
                        : [
                            {ip:5, note:`SSE blocks x${blocks} (—Å–∏–º–≤.)`},
                            {ip:8, note:'tail via rep movsb'},
                            {ip:8, regs:{rsi:BigInt(afterRSI), rdi:BigInt(afterRDI), rcx:0n}},
                            {ip:9}
                        ]
                    )
                ];
                return {
                    id:'', title:'üöÄ memcpy: SSE vs rep movsb',
                    goal:`RSI=${hexs(afterRSI)}, RDI=${hexs(afterRDI)}, RCX=0`,
                    hint:'>=16 –±–∞–π—Ç ‚Äî –±–ª–æ—á–Ω–æ movdqu; –æ—Å—Ç–∞—Ç–æ–∫/–º–∞–ª—ã–µ ‚Äî rep movsb',
                    explanation:'–ì–∏–±—Ä–∏–¥–Ω–∞—è memcpy: –±–æ–ª—å—à–∏–µ –∫—É—Å–∫–∏ SSE, —Ö–≤–æ—Å—Ç ‚Äî byte copy. –°–∏–º—É–ª—è—Ü–∏—è –±–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏.',
                    base, strings:['movdqu','rep movsb','memcpy'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> s.regs.rsi===BigInt(afterRSI) && s.regs.rdi===BigInt(afterRDI) && s.regs.rcx===0n
                };
            }
        },

        // === ASLR/PIC: RIP-relative load + printf@plt ===
        pic_rip_printf: {
            label:'ASLR/PIC: RIP-relative + printf@plt',
            params:[
                {key:'fmt_off',label:'fmt @ .rodata (hex)',def:'0x402100'},
                {key:'str_off',label:'str @ .rodata (hex)',def:'0x402120'}
            ],
            build:(p)=>{
                const fmt=parseInt(p.fmt_off,16)||0x402100;
                const str=parseInt(p.str_off,16)||0x402120;
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'48 8d 3d 00 21 40 00', s:`lea rdi, [rip+${hexs(fmt)}] ; "%s\\n"`},
                    {a:base+0x07,b:'48 8d 35 20 21 40 00', s:`lea rsi, [rip+${hexs(str)}] ; string`},
                    {a:base+0x0e,b:'31 c0', s:'xor eax, eax  ; SysV: AL=0 for varargs (float cnt)'},
                    {a:base+0x10,b:'e8 0b 00 00 00', s:'call 0x401020 ; printf@plt'},
                    {a:base+0x15,b:'c3', s:'ret'},

                    // plt-—Å—Ç–∞–± (—É–ø—Ä–æ—â—ë–Ω)
                    {a:base+0x20,b:'ff 25 02 2f 00 00', s:'printf@plt: jmp [rip+GOT]'}
                ];
                const trace=[
                    {ip:0, regs:{rdi:BigInt(fmt)}, note:'RDI ‚Üê fmt (RIP-rel)'},
                    {ip:1, regs:{rsi:BigInt(str)}, note:'RSI ‚Üê str (RIP-rel)'},
                    {ip:2, note:'AL=0 (SysV varargs)'},
                    {ip:3, note:'call printf@plt ‚Üí GOT ‚Üí libc printf'},
                    {ip:4, note:'ret'}
                ];
                return {
                    id:'', title:'üìç PIC + printf@plt',
                    goal:'–ü–æ–Ω—è—Ç—å RIP-relative addressing + varargs AL=0',
                    hint:'LEA rdi/rsi —Å rip-—Å–º–µ—â–µ–Ω–∏–µ–º, –∑–∞—Ç–µ–º printf@plt',
                    explanation:'PIC –ø–æ–¥ ASLR: —Å—Ç—Ä–æ–∫–∏ –±–µ—Ä—ë–º RIP-relative, —Ñ—É–Ω–∫—Ü–∏–∏ ‚Äî —á–µ—Ä–µ–∑ PLT/GOT.',
                    base, strings:['printf@plt','RIP-relative','.rodata'],
                    disasm, cfg:callCFG('main','printf@plt'),
                    trace, check:(s)=> s.ipIndex>=4
                };
            }
        },

        // === TLS Canary: fast (match) / slow (mismatch ‚Üí __stack_chk_fail) ===
        tls_canary_paths: {
            label:'TLS canary: fast/slow path',
            params:[ {key:'corrupt',label:'corrupt? (0|1)',def:'0'} ],
            build:(p)=>{
                const corrupt=(+p.corrupt|0)?1:0;
                const tls = 0x1234567890abcdn;
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'55', s:'push rbp'},
                    {a:base+0x01,b:'48 89 e5', s:'mov rbp, rsp'},
                    {a:base+0x04,b:'64 48 8b 04 25 28 00 00 00', s:'mov rax, qword ptr fs:0x28 ; canary'},
                    {a:base+0x0d,b:'48 89 45 f8', s:'mov [rbp-8], rax'},
                    // ... body ...
                    {a:base+0x11,b:'48 8b 45 f8', s:'mov rax, [rbp-8]'},
                    {a:base+0x15,b:'64 48 33 04 25 28 00 00 00', s:'xor rax, qword ptr fs:0x28'},
                    {a:base+0x1e,b:'74 07', s:'je .ok'},
                    {a:base+0x20,b:'e8 00 00 00 00', s:'call __stack_chk_fail'},
                    {a:base+0x25,b:'b8 ff ff ff ff', s:'.ok: mov eax, -1'}, // –≤–µ—Ä–Ω—ë–º -1 –ø—Ä–∏ –û–ö (–¥–ª—è –æ—Ç–ª–∏—á–∏—è –ø—É—Ç–µ–π)
                    {a:base+0x2a,b:'5d', s:'pop rbp'},
                    {a:base+0x2b,b:'c3', s:'ret'}
                ];
                const ok = corrupt?0:1;
                const trace = corrupt
                    ? [
                        {ip:0},{ip:1},
                        {ip:2, regs:{rax:tls}, note:'load canary'},
                        {ip:3, note:'save canary'},
                        {ip:4, regs:{rax:tls}, note:'reload shadow'},
                        {ip:5, regs:{rax:1n}, flags:{zf:0}, note:'XOR ‚â† 0 ‚Üí mismatch'},
                        {ip:6, note:'JE not taken'},
                        {ip:7, note:'__stack_chk_fail (—Å–∏–º–≤.)'},
                        {ip:10, note:'ret'}
                    ]
                    : [
                        {ip:0},{ip:1},
                        {ip:2, regs:{rax:tls}, note:'load canary'},
                        {ip:3, note:'save canary'},
                        {ip:4, regs:{rax:tls}, note:'reload shadow'},
                        {ip:5, regs:{rax:0n}, flags:{zf:1}, note:'XOR ‚Üí 0 (match)'},
                        {ip:6, note:'JE taken ‚Üí .ok'},
                        {ip:8, regs:{rax:0xffffffffn}, note:'EAX=-1 (ok-path marker)'},
                        {ip:9},{ip:10}
                    ];
                return {
                    id:'', title:'üõ°Ô∏è TLS Canary: fast/slow',
                    goal: corrupt ? 'Slow path: mismatch triggers __stack_chk_fail'
                                : 'Fast path: JE taken, EAX=-1',
                    hint:'–°—Ä–∞–≤–Ω–∏–≤–∞–µ–º saved canary —Å TLS fs:0x28 –ø–µ—Ä–µ–¥ –≤–æ–∑–≤—Ä–∞—Ç–æ–º',
                    explanation:'Fast-path: –∫–∞–Ω–∞—Ä–µ–π–∫–∞ —Å–æ–≤–ø–∞–ª–∞. Slow-path: –Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ‚Üí __stack_chk_fail.',
                    base, strings:['__stack_chk_fail','TLS','fs:0x28'],
                    disasm, cfg:branchCFG(),
                    trace, check:(s)=> corrupt ? s.ipIndex>=7 : (s.regs.rax===0xffffffffn)
                };
            }
        },

        // === BMI2 64-bit: gather‚Üíscatter (step) ===
        bmi2_pext_pdep64_step: {
            label: 'BMI2 64-bit: gather‚Üíscatter (step)',
            params: [
                { key:'src',  label:'src (u64 hex)',  def:'0xdeadbeefcafebabe' },
                { key:'gmsk', label:'gather mask',   def:'0x0000f0f00f0ff00f' },
                { key:'smsk', label:'scatter mask',  def:'0x00f0000ff0000f00' }
            ],
            build:(p)=>{
                const base=0x401000;
                const disasm=[
                    {a:base+0x00,b:'‚Äî',s:'; PEXT (gather) ‚Üí compact stream'},
                    {a:base+0x02,b:'‚Äî',s:'; PDEP (scatter) ‚Üí final layout'},
                    {a:base+0x04,b:'‚Äî',s:'ret'}
                ];
                const explanation = `
                    <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                        –ü–æ—à–∞–≥–æ–≤–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏–∏: —Å–Ω–∞—á–∞–ª–∞ <b>gather</b> (PEXT), –∑–∞—Ç–µ–º <b>scatter</b> (PDEP).
                    </div>
                    <div id="qviz2" style="width:100%;max-height:520px;overflow:auto;"></div>
                    <div style="margin-top:8px">
                        <button class="btn" id="qbtn-run">‚ñ∂Ô∏è Run</button>
                    </div>
                `;
                const trace=[{ip:0},{ip:1},{ip:2}];

                const mount = ()=>{
                    const stop = bitRouteStepViz('qviz2', p.src, p.gmsk, p.smsk);
                    const btn = document.getElementById('qbtn-run');
                    if (btn) btn.onclick = () => bitRouteStepViz('qviz2', p.src, p.gmsk, p.smsk);
                };

                return {
                    id:'', title:'üß© BMI2 step viz',
                    goal:'–ü–æ—Å–º–æ—Ç—Ä–∏ –Ω–∞ —à–∞–≥–∏ gather‚Üíscatter',
                    hint:'–ê–∫—Ç–∏–≤–Ω—ã–º–∏ –ø–æ–¥—Å–≤–µ—á–∏–≤–∞—é—Ç—Å—è –ª–∏–Ω–∏–∏, –≥–¥–µ –±–∏—Ç=1.',
                    explanation, base, strings:['pext','pdep','viz','step'],
                    disasm, cfg: linearCFG(disasm, 'pext/pdep step'),
                    trace, check: _=>true, mount
                };
            }
        },

        // === Vector Saturating mul (int32x4) ‚Äî SSE/NEON (symbolic) ===
        saturating_mul_i32x4_vector: {
            label: 'Vector Saturating mul (int32x4) ‚Äî SSE/NEON (symbolic)',
            params: [
                { key:'a', label:'a (4√óint32, CSV)', def:'1600000000, 2, -2000000000, 12345' },
                { key:'b', label:'b (4√óint32, CSV)', def:'3, -10, 2, 67890' },
                { key:'arch', label:'arch (sse|neon)', def:'sse' }
            ],
            build:(p)=>{
                const MIN=-2147483648n, MAX=2147483647n;
                const parse4 = s => s.split(',').map(x=>BigInt.asIntN(32, BigInt(x.trim()))).slice(0,4);
                const A=parse4(p.a), B=parse4(p.b);
                const wide=A.map((x,i)=> x*B[i]);
                const sat=wide.map(w => w<MIN?MIN : (w>MAX?MAX : w));
                const out = sat.map(w=> Number(BigInt.asIntN(32,w)));

                const base=0x401000;
                const disasm = (p.arch==='sse')
                    ? [
                        {a:base+0x00,b:'‚Äî', s:'; XMM0 <- a[4], XMM1 <- b[4]'},
                        {a:base+0x02,b:'‚Äî', s:'; pmulld xmm2, xmm0, xmm1   ; (–º–æ–¥–µ–ª—å: wide)'},
                        {a:base+0x04,b:'‚Äî', s:'; clamp each lane to int32 range'},
                        {a:base+0x06,b:'‚Äî', s:'ret'}
                    ]
                    : [
                        {a:base+0x00,b:'‚Äî', s:'; NEON: V0.4S <- a, V1.4S <- b'},
                        {a:base+0x02,b:'‚Äî', s:'; mul v2.4s, v0.4s, v1.4s    ; (–º–æ–¥–µ–ª—å: wide)'},
                        {a:base+0x04,b:'‚Äî', s:'; clamp lanes to int32 range'},
                        {a:base+0x06,b:'‚Äî', s:'ret'}
                    ];

                const explanation = `
                    <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                        –í–µ–∫—Ç–æ—Ä–Ω–æ–µ –Ω–∞—Å—ã—â–∞—é—â–µ–µ —É–º–Ω–æ–∂–µ–Ω–∏–µ 4√óint32: —Å–Ω–∞—á–∞–ª–∞ ¬´—à–∏—Ä–æ–∫–∏–π¬ª –ø—Ä–æ–¥—É–∫—Ç –ø–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ, –∑–∞—Ç–µ–º clamp –∫ [-2^31, 2^31-1].<br/>
                        <code>${p.arch.toUpperCase()}</code> –ø—É—Ç—å –ø–æ–∫–∞–∑–∞–Ω —Å–∏–º–≤–æ–ª–∏—á–µ—Å–∫–∏ (–±–µ–∑ –±–∞–π—Ç).
                    </div>
                    <div style="font-size:12px;opacity:.8">out = [${out.join(', ')}]</div>
                `;

                const trace = [
                    {ip:0, note:`A=${A.map(n=>n.toString()).join(', ')}`},
                    {ip:1, note:`B=${B.map(n=>n.toString()).join(', ')}`},
                    {ip:2, note:`wide=${wide.map(n=>n.toString()).join(', ')}`},
                    {ip:3, note:`sat=${sat.map(n=>n.toString()).join(', ')}`},
                    {ip:4}
                ];

                return {
                    id:'', title:'üßØ Saturating mul int32x4 (vector symbolic)',
                    goal:`–í—ã–≤–µ—Å—Ç–∏ –≤–µ–∫—Ç–æ—Ä out –ø–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ: ${out.join(', ')}`,
                    hint:'–®–∏—Ä–æ–∫–∏–π –ø—Ä–æ–¥—É–∫—Ç ‚Üí clamp –¥–ª—è –∫–∞–∂–¥–æ–≥–æ lane.',
                    explanation, base, strings:['sse','neon','saturating','vector'],
                    disasm, cfg: linearCFG(disasm, 'sat mul i32x4'),
                    trace, check: _=>true
                };
            }
        },

        // === ARM64 SQRDMULH (Q31, rounding double) ‚Äî symbolic ===
        arm64_sqrdmulh_q31: {
            label: 'ARM64: SQRDMULH (Q31, symbolic)',
            params: [
                { key:'a', label:'a (int32, Q31)', def:'1073741824' },  // ~0.5 in Q31
                { key:'b', label:'b (int32, Q31)', def:'1610612736' }   // ~0.75 in Q31
            ],
            build:(p)=>{
                const toI32 = v=> BigInt.asIntN(32, BigInt(v));
                const a = toI32(p.a), b = toI32(p.b);
                // semantics: sat( round( (2*a*b) >> 31 ) )
                const round = 1n<<30n;
                let tmp = 2n * a * b + round;  // rounding
                let res = tmp >> 31n;          // shift back to Q31
                const MIN=-2147483648n, MAX=2147483647n;
                if (res<MIN) res=MIN; else if (res>MAX) res=MAX;

                const base=0x401000;
                const disasm = [
                    {a:base+0x00,b:'‚Äî', s:`mov w0, #${Number(a)}`},
                    {a:base+0x02,b:'‚Äî', s:`mov w1, #${Number(b)}`},
                    {a:base+0x04,b:'‚Äî', s:'; sqrdmulh w2, w0, w1  (Q31 rounding-double)'},
                    {a:base+0x06,b:'‚Äî', s:'; w2 = sat( (2*w0*w1 + 1<<30) >> 31 )'},
                    {a:base+0x08,b:'‚Äî', s:'mov w2, #<computed>'},
                    {a:base+0x0a,b:'‚Äî', s:'ret'}
                ];

                const explanation = `
                    <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                        <b>SQRDMULH Q31</b>: —É–¥–≤–æ–µ–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç (double), –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ, —Å–¥–≤–∏–≥ –Ω–∞ 31 –∏ –Ω–∞—Å—ã—â–µ–Ω–∏–µ –∫ int32.
                    </div>
                    <div style="font-size:12px;opacity:.8">result (W2) = ${Number(res)}</div>
                `;

                const trace = [
                    {ip:0, regs:{w0:a}},
                    {ip:1, regs:{w1:b}},
                    {ip:4, regs:{w2:res}, note:`sqrdmulh(Q31) ‚Üí ${Number(res)}`},
                    {ip:5}
                ];

                return {
                    id:'', title:'üßÆ ARM64 SQRDMULH (Q31, symbolic)',
                    goal:`W2 == ${Number(res)}`,
                    hint:'2√óa√ób + round, –ø–æ—Ç–æ–º >>31 –∏ saturate.',
                    explanation, base, strings:['sqrdmulh','Q31','saturate','rounding'],
                    disasm, cfg: linearCFG(disasm,'sqrdmulh Q31'),
                    trace, check:_=>true
                };
            }
        },
        // === BMI2: Interactive PEXT/PDEP (64-bit) ===
        bmi2_pext_pdep64_interactive: {
            label: 'BMI2: Interactive PEXT/PDEP (64-bit)',
            params: [
                { key:'src', label:'src (u64 hex)', def:'0xdeadbeefcafebabe' }
            ],
            build:(p)=>{
                const explain = `
                  <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                    –ö–ª–∏–∫–Ω–∏ –ø–æ –Ω–æ–º–µ—Ä–∞–º –±–∏—Ç–æ–≤, —á—Ç–æ–±—ã –≤–∫–ª—é—á–∞—Ç—å/–≤—ã–∫–ª—é—á–∞—Ç—å <b>gather mask</b> –∏ <b>scatter mask</b>.<br/>
                    –°–ª–µ–≤–∞ –±–µ—Ä—ë–º –±–∏—Ç—ã –∏–∑ <code>src</code> –ø–æ gather, —É–ø–ª–æ—Ç–Ω—è–µ–º (PEXT), –∑–∞—Ç–µ–º —Ä–∞—Å–∫–ª–∞–¥—ã–≤–∞–µ–º –ø–æ scatter (PDEP).
                  </div>
                  <div class="bitbar">
                    <div>src:</div><code id="ix-src"></code>
                    <div>gmask:</div><code id="ix-g"></code>
                    <div>smask:</div><code id="ix-s"></code>
                    <div>gathered:</div><code id="ix-pext"></code>
                    <div>scattered:</div><code id="ix-pdep"></code>
                  </div>
                  <div id="ix-grids"></div>
                `;
                const base=0x401000;
                const disasm = [
                    {a:base+0x00,b:'‚Äî',s:'; interactive PEXT/PDEP (symbolic)'},
                    {a:base+0x02,b:'‚Äî',s:'ret'}
                ];
                const trace=[{ip:0},{ip:1}];

                const mount = ()=>{
                    const src = BigInt.asUintN(64, BigInt(p.src));
                    const cont = document.getElementById('ix-grids');
                    cont.innerHTML='';
                    const gBits = new Set([0,1,2,3,4,5,6,7]); // —Å—Ç–∞—Ä—Ç–æ–≤–∞—è –º–∞—Å–∫–∞
                    const sBits = new Set([16,18,20,22,24,26,28,30]);

                    const update = ()=>{
                        const gmask = bitsToMask(gBits);
                        const smask = bitsToMask(sBits);
                        const gathered = pext64(src, gmask);
                        const scattered= pdep64(gathered, smask);
                        const $ = id=>document.getElementById(id);
                        $('ix-src').textContent   = '0x'+src.toString(16);
                        $('ix-g').textContent     = '0x'+gmask.toString(16);
                        $('ix-s').textContent     = '0x'+smask.toString(16);
                        $('ix-pext').textContent  = '0x'+gathered.toString(16);
                        $('ix-pdep').textContent  = '0x'+scattered.toString(16);
                    };

                    const gWrap = document.createElement('div');
                    const sWrap = document.createElement('div');
                    cont.appendChild(gWrap); cont.appendChild(sWrap);
                    buildBitGrid(gWrap, gBits, {label:'Gather mask (PEXT)', toggle:update});
                    buildBitGrid(sWrap, sBits, {label:'Scatter mask (PDEP)', toggle:update});
                    update();
                };

                return {
                    id:'', title:'üß© PEXT/PDEP Interactive',
                    goal:'–ò–≥—Ä–∞–π—Å—è —Å –º–∞—Å–∫–∞–º–∏ –∏ –Ω–∞–±–ª—é–¥–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.',
                    hint:'PEXT ‚Üí compact; PDEP ‚Üí redistribute.',
                    explanation: explain, base, strings:['pext','pdep','interactive'],
                    disasm, cfg: linearCFG(disasm,'pext/pdep interactive'),
                    trace, check:_=>true, mount
                };
            }
        },

        // === Register Diff (demo) ===
        regdiff_demo: {
            label:'Register Diff (demo)',
            params:[],
            build:()=>{
                const explain = `
                  <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                    –ü–∞–Ω–µ–ª—å –Ω–∏–∂–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ <code>step()</code>.
                  </div>
                  <div id="regdiff-panel" style="padding:8px;background:rgba(255,255,255,.03);border-radius:8px;border:1px solid #2a3a4c"></div>
                `;
                const base=0x401000, disasm=[{a:base,b:'‚Äî',s:'ret'}], trace=[{ip:0}];
                const mount = ()=> makeRegDiffPanel('regdiff-panel');
                return {
                    id:'', title:'üìä Register Diff',
                    goal:'–°–º–æ—Ç—Ä–∏ –¥–µ–ª—å—Ç—ã –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —à–∞–≥–∞.',
                    hint:'–•—É–∫ addStepHook("regdiff", cb).',
                    explanation: explain, base, strings:['regs','diff','hooks'],
                    disasm, cfg: linearCFG(disasm,'reg diff'),
                    trace, check:_=>true, mount
                };
            }
        },

        // === CTF: Fix magic division (u32) ===
        ctf_magic_div_u32: {
            label:'CTF: Fix magic division (u32)',
            params:[
                {key:'d', label:'divisor d (odd 3..2^32-1)', def:'7'},
                {key:'m', label:'magic m (u64 hex)', def:'0x0000000000000000'},
                {key:'s', label:'shift s (32..64)', def:'35'},
                {key:'samples', label:'samples (count)', def:'200'}
            ],
            build:(p)=>{
                const d = BigInt(parseInt(p.d,10));
                if (d<=1n) throw new Error('d must be >1');
                const m = BigInt(p.m);
                const s = BigInt(parseInt(p.s,10));
                const cnt = Math.max(50, parseInt(p.samples,10)||200);

                // –¢–µ—Å—Ç–µ—Ä: –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ n (–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —É–≥–ª—ã)
                function ok(ms, verbose=false){
                    const mask32 = (1n<<32n)-1n;
                    function q_magic(n){ return ((n * ms.m) >> ms.s) & mask32; }
                    function q_true(n){ return n / d; }
                    // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–µ–π—Å—ã
                    const fixed = [0n,1n,2n, (1n<<32n)-1n, (1n<<32n)-2n, (1n<<31n), (1n<<31n)-1n];
                    for (const n of fixed){
                        if (q_magic(n)!==q_true(n)) return {pass:false, n};
                    }
                    // —Å–ª—É—á–∞–π–Ω—ã–µ
                    for (let i=0;i<cnt;i++){
                        const n = BigInt.asUintN(32, BigInt(Math.floor(Math.random()*2**32)));
                        if (q_magic(n)!==q_true(n)) return {pass:false, n};
                    }
                    return {pass:true};
                }

                const result = ok({m,s});
                const base=0x401000;
                const disasm = [
                    {a:base+0x00,b:'‚Äî',s:`; Goal: –ø–æ–¥–æ–±—Ä–∞—Ç—å m,s –¥–ª—è –¥–µ–ª–µ–Ω–∏—è –Ω–∞ d=${d}`},
                    {a:base+0x02,b:'‚Äî',s:`; q ‚âü (n*m)>>s  == floor(n/d)  for all n‚ààu32`},
                    {a:base+0x04,b:'‚Äî',s:'ret'}
                ];
                const feedback = result.pass
                  ? `<div style="color:#4df3a3">‚úì PASS ‚Äî —Ç–≤–æ–∏ m,s –ø—Ä–æ—Ö–æ–¥—è—Ç —Ç–µ—Å—Ç—ã</div>`
                  : `<div style="color:#ff5c7a">‚úó FAIL ‚Äî –Ω–∞–π–¥—ë–Ω –∫–æ–Ω—Ç—Ä–ø—Ä–∏–º–µ—Ä n=${result.n}</div>`;

                const hint = `
                  <details style="margin-top:8px"><summary>Hint</summary>
                    –î–ª—è –Ω–µ—á—ë—Ç–Ω—ã—Ö d —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –º–∞–≥–∏—á–µ—Å–∫–æ–µ m‚âà‚åä(2^(32+s))/d‚åã+1, –ø–æ–¥–±–µ—Ä–∏ s‚àà[32..64].
                    –ü–æ–¥—Ä–æ–±–Ω–µ–µ: Hacker's Delight, div by constants.
                  </details>
                `;

                const explanation = `
                  <div style="margin:10px 0;padding:10px;border-left:3px solid var(--neon);background:rgba(73,247,194,.06);border-radius:8px;">
                    –ú–∏–Ω–∏-CTF: –ø–æ–¥–±–µ—Ä–∏ <code>m</code> –∏ <code>s</code>, —á—Ç–æ–±—ã —Å—Ö–µ–º–∞ <code>(n*m) >> s</code> —Ç–æ—á–Ω–æ –¥–µ–ª–∏–ª–∞ u32 –Ω–∞ d=${d}.
                  </div>
                  <div class="bitbar">m: <code>${'0x'+m.toString(16)}</code> &nbsp; s: <code>${s.toString()}</code></div>
                  ${feedback}
                  ${hint}
                `;

                const trace=[{ip:0},{ip:1},{ip:2}];

                return {
                    id:'', title:'üéØ CTF: magic division (u32)',
                    goal:'–ü–æ–¥–±–µ—Ä–∏ m,s —Ç–∞–∫, —á—Ç–æ–±—ã PASS.',
                    hint:'–ò—â–µ–º m‚âà(2^(32+s))/d, –∑–∞—Ç–µ–º –ø—Ä–æ–≤–µ—Ä—è–µ–º.',
                    explanation, base, strings:['ctf','magic','division','u32'],
                    disasm, cfg: linearCFG(disasm,'ctf magic'),
                    trace,
                    check:(_)=> ok({m,s}).pass
                };
            }
        }
    }
};

// helpers
function toImm32(n){ return [n&0xff, (n>>8)&0xff, (n>>16)&0xff,(n>>24)&0xff].map(x=>x.toString(16).padStart(2,'0')).join(' ') }
function toImm8(n){ return (n&0xff).toString(16).padStart(2,'0') }
function toImm64(n){
    const b=BigInt(n)&0xffffffffffffffffn;
    const bytes=[];
    for(let i=0;i<8;i++) bytes.push(Number((b>>(BigInt(i)*8n))&0xffn));
    return bytes.map(x=>x.toString(16).padStart(2,'0')).join(' ');
}
function hexs(n){ return '0x'+n.toString(16) }

// --- step hooks: –ø–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –∫–∞–∂–¥—ã–π step() ---
const __StepHooks = new Map();
function addStepHook(name, cb){ __StepHooks.set(name, cb); }
function removeStepHook(name){ __StepHooks.delete(name); }

// –æ–±–µ—Ä–Ω—É—Ç—å –≤–∞—à step() –æ–¥–∏–Ω —Ä–∞–∑ –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è step()
if (!window.__step_patched) {
  const __orig_step = window.step;
  window.step = function(){
    const r = __orig_step.apply(this, arguments);
    try { __StepHooks.forEach(cb => { try{ cb(); }catch(e){} }); } catch(e){}
    return r;
  };
  window.__step_patched = true;
}

// --- —Ä–µ–≥-—É—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –∫–æ–ø–∏–∏ —Ç–µ–∫—É—â–∏—Ö —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ (State.regs ‚Üí plain object) ---
function snapshotRegs(){ 
  const o={}; Object.entries(State.regs).forEach(([k,v])=>o[k]=v);
  return o;
}

// step-anim helper: –∑–∞–ø—É—Å–∫–∞–µ—Ç –∫–æ–ª–ª–±–µ–∫ –Ω–∞ –∫–∞–∂–¥–æ–º —à–∞–≥–µ (–¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏)
function stepAnimator(steps, render, {interval=500}={}) {
  let i = 0; const id = setInterval(() => {
    render(steps[i], i);
    i++; if (i>=steps.length) clearInterval(id);
  }, interval);
  return () => clearInterval(id);
}

function bitRouteStepViz(containerId, src, gmask, smask){
  const N=64, W=820, H=N*10+80, Lx=120, Cx=W/2, Rx=W-120;
  const NS='http://www.w3.org/2000/svg';
  const u64 = v=>BigInt.asUintN(64, BigInt(v));
  const srcU=u64(src), gm=u64(gmask), sm=u64(smask);

  const idxs = (m)=>{ const r=[]; for(let i=0;i<N;i++) if(((m>>BigInt(i))&1n)===1n) r.push(i); return r; };
  const gi=idxs(gm), si=idxs(sm);

  const get = (x,i)=> Number((u64(x)>>BigInt(i))&1n);

  const c = document.getElementById(containerId);
  c.innerHTML='';
  const svg=document.createElementNS(NS,'svg');
  svg.setAttribute('class','bitviz2');
  svg.setAttribute('width','100%');
  svg.setAttribute('viewBox',`0 0 ${W} ${H}`);

  const text=(x,y,t)=>{const tx=document.createElementNS(NS,'text'); tx.setAttribute('x',x); tx.setAttribute('y',y); tx.textContent=t; svg.appendChild(tx);};
  text(Lx-60,18,'SRC'); text(Cx-20,18,'PEXT'); text(Rx+14,18,'PDEP');

  // dots columns
  const dot=(x,y,fill)=>{const g=document.createElementNS(NS,'g'); const cc=document.createElementNS(NS,'circle'); cc.setAttribute('cx',x); cc.setAttribute('cy',y); cc.setAttribute('r',3.2); if(fill) cc.setAttribute('fill','#49f7c230'); g.appendChild(cc); return g;};
  for(let i=0;i<N;i++){ svg.appendChild(dot(Lx, 30+i*10, get(srcU,i))); }
  for(let k=0;k<gi.length;k++){ svg.appendChild(dot(Cx, 30+k*10, false)); }
  for(let i=0;i<N;i++){ svg.appendChild(dot(Rx, 30+i*10, false)); }

  // step lines (gather then scatter)
  const gatherLines=[], scatterLines=[];
  gi.forEach((from,k)=>{
    const y1=30+from*10, y2=30+k*10;
    const ln=document.createElementNS(NS,'line');
    ln.setAttribute('x1',Lx+4); ln.setAttribute('y1',y1);
    ln.setAttribute('x2',Cx-4); ln.setAttribute('y2',y2);
    svg.appendChild(ln); gatherLines.push({ln, on:get(srcU,from)});
  });
  si.forEach((to,k)=>{
    const y1=30+k*10, y2=30+to*10;
    const ln=document.createElementNS(NS,'line');
    ln.setAttribute('x1',Cx+4); ln.setAttribute('y1',y1);
    ln.setAttribute('x2',Rx-4); ln.setAttribute('y2',y2);
    svg.appendChild(ln); scatterLines.push({ln, k});
  });

  // legend/status
  const st=document.createElementNS(NS,'text');
  st.setAttribute('x', 20); st.setAttribute('y', H-20);
  st.textContent='Step: 0';
  svg.appendChild(st);

  c.appendChild(svg);

  const steps=[];
  // gather steps
  for(let k=0;k<gatherLines.length;k++) steps.push({phase:'gather', k});
  // scatter steps
  for(let k=0;k<scatterLines.length;k++) steps.push({phase:'scatter', k});

  const render=(s, i)=>{
    st.textContent = `Step: ${i+1}/${steps.length} (${s.phase})`;
    if(s.phase==='gather'){
      const g = gatherLines[s.k];
      g.ln.classList.toggle('active', !!g.on);
    } else {
      const sc = scatterLines[s.k];
      // –∞–∫—Ç–∏–≤–∏—Ä—É–µ–º scatter –ª–∏–Ω–∏—é —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π compact-–±–∏—Ç = 1
      const on = (()=>{
        // compact bit ‚Äî —ç—Ç–æ –±–∏—Ç ‚Ññk –ø–æ—Å–ª–µ PEXT
        // –æ–Ω —Ä–∞–≤–µ–Ω 1, –µ—Å–ª–∏ –≤ gatherLines[k] –±—ã–ª on
        return gatherLines[s.k]?.on === 1;
      })();
      sc.ln.classList.toggle('active', on);
    }
  };

  return stepAnimator(steps, render, {interval: 500});
}

function buildBitGrid(container, bits, {label, toggle}) {
  const root = document.createElement('div');
  const title = document.createElement('div'); title.textContent = label; title.style.margin='6px 0';
  const grid = document.createElement('div'); grid.className='bitgrid';
  for (let i=63;i>=0;i--) {
    const el = document.createElement('div'); el.className='bit';
    if (bits.has(i)) el.classList.add('on');
    el.textContent = i;
    el.title = `bit ${i} (toggle)`;
    el.onclick = ()=>{ if (bits.has(i)) bits.delete(i); else bits.add(i); el.classList.toggle('on'); toggle(); };
    grid.appendChild(el);
  }
  root.appendChild(title); root.appendChild(grid);
  container.appendChild(root);
}

function pext64(s, m){ let out=0n, bit=0n; for(let i=0n;i<64n;i++){ if((m>>i)&1n){ if((s>>i)&1n) out|=(1n<<bit); bit++; } } return out; }
function pdep64(s, m){ let out=0n, bit=0n; for(let i=0n;i<64n;i++){ if((m>>i)&1n){ if((s>>bit)&1n) out|=(1n<<i); bit++; } } return out; }
function bitsToMask(set){ let m=0n; set.forEach(i=> m |= (1n<<BigInt(i))); return m; }

function makeRegDiffPanel(containerId){
  const cont = document.getElementById(containerId);
  if (!cont) return;
  cont.innerHTML = `
    <div style="font-weight:bold;color:var(--neon)">Register Diff</div>
    <div id="rd-prev" style="font-size:11px;color:var(--muted);margin:4px 0">prev: ‚Äî</div>
    <div id="rd-changes" style="font-size:12px;line-height:1.5"></div>
  `;
  let prev = snapshotRegs();

  const fmt = v=>'0x'+(BigInt(v).toString(16).padStart(1,'0'));
  const paint = ()=>{
    const cur = snapshotRegs();
    const changes = [];
    for (const k of Object.keys(cur)) {
      if (prev[k]!==cur[k]) {
        changes.push(`<div>‚Ä¢ <b>${k.toUpperCase()}</b>: ${fmt(prev[k])} ‚Üí <span style="color:#7ea8ff">${fmt(cur[k])}</span></div>`);
      }
    }
    document.getElementById('rd-prev').textContent = 'prev RIP: '+fmt(prev.rip||0n);
    document.getElementById('rd-changes').innerHTML = changes.length ? changes.join('') : '<i>no changes</i>';
    prev = cur;
  };

  addStepHook('regdiff', paint); // –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å
  // –æ—Ç–ø–∏—Å–∫–∞ –ø—Ä–∏ —É—Ö–æ–¥–µ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã/—à–∞–±–ª–æ–Ω–∞ ‚Äî –ø–æ –∂–µ–ª–∞–Ω–∏—é:
  // removeStepHook('regdiff')
}

function linearCFG(disasm,label){
    return {blocks:[{id:'B0',x:200,y:80,width:200,height:80,instrs:disasm.map((_,i)=>i),label:`${label}\n${disasm.length} instruction${disasm.length > 1 ? 's' : ''}\n(sequential flow)`}],edges:[]}
}

function loopCFG(){
    return {
        blocks:[
            {id:'Entry',x:250,y:40,width:150,height:60,instrs:[0],label:'Initialization\nSetup loop counter'},
            {id:'Body',x:250,y:160,width:180,height:80,instrs:[1,2],label:'Loop Body\nProcess iteration\ndec rcx; jnz Body'},
            {id:'Exit',x:250,y:280,width:150,height:60,instrs:[3],label:'Exit\nLoop completed'}
        ],
        edges:[
            {from:'Entry',to:'Body',type:'fall',label:'Start loop'},
            {from:'Body',to:'Body',type:'branch',label:'RCX ‚â† 0'},
            {from:'Body',to:'Exit',type:'fall',label:'RCX = 0'}
        ]
    }
}

function branchCFG(){
    return {
        blocks:[
            {id:'Cond',x:200,y:40,width:200,height:80,instrs:[0,1,2,3,4],label:'Condition Check\ncmp reg, value\nConditional jump'},
            {id:'False',x:80,y:180,width:180,height:70,instrs:[5,6],label:'False Path\nZF = 0\nAlternative code'},
            {id:'True',x:380,y:180,width:180,height:70,instrs:[7,8],label:'True Path\nZF = 1\nPrimary code'},
            {id:'Merge',x:200,y:300,width:200,height:60,instrs:[9,10],label:'Merge Point\nContinue execution'}
        ],
        edges:[
            {from:'Cond',to:'False',type:'fall',label:'ZF = 0'},
            {from:'Cond',to:'True',type:'branch',label:'ZF = 1'},
            {from:'False',to:'Merge',type:'fall',label:'Continue'},
            {from:'True',to:'Merge',type:'fall',label:'Continue'}
        ]
    }
}

function callCFG(entry, callee){
    return {
        blocks:[
            {id:'Caller', x:150, y:40, width:200, height:100, instrs:[0,1,2,3], label:`${entry}\nSetup parameters\ncall ${callee}\nHandle return value`},
            {id:'Callee', x:400, y:60, width:220, height:120, instrs:[4,5,6,7,8,9,10,11], label:`${callee}()\nFunction prologue\nProcess logic\nFunction epilogue\nReturn to caller`},
            {id:'Return', x:150, y:200, width:200, height:80, instrs:[12,13], label:'Return Point\nCheck return value\nContinue execution'}
        ],
        edges:[
            {from:'Caller', to:'Callee', type:'call', label:'Function call'},
            {from:'Callee', to:'Return', type:'return', label:'Return'}
        ]
    }
}

function tableCFG(labels){
    // Draw switch statement with entry and N cases
    const baseX=200, baseY=40;
    const blocks=[{id:'Switch', x:baseX, y:baseY, width:200, height:80, instrs:[0,1,2,3], label:'Switch Statement\nCompare value\nJump to case'}];
    const edges=[];
    const colStart=100, gap=150;
    
    // Add default case at the end
    labels.forEach((lab, i)=>{
        const id=`Case${i}`;
        blocks.push({id, x:colStart+i*gap, y:200, width:140, height:70, instrs:[], label:`${lab}\nCase ${i}\nProcess logic`});
        edges.push({from:'Switch',to:id, type:'branch', label: i<labels.length-1?`value = ${i}`:'default'});
    });
    
    // Add merge point
    blocks.push({id:'Merge', x:baseX, y:320, width:200, height:60, instrs:[], label:'Continue Execution\nAfter switch statement'});
    
    // Connect all cases to merge point
    for(let i=0; i<labels.length; i++) {
        edges.push({from:`Case${i}`, to:'Merge', type:'fall', label:'Break'});
    }
    
    return {blocks, edges};
}

// storage
function qLoadAll(){ return LS.get(QODER_LS_KEY, []) }
function qSaveAll(arr){ LS.set(QODER_LS_KEY, arr) }
function qUpsert(lesson){
    const arr=qLoadAll();
    const i=arr.findIndex(x=>x.id===lesson.id);
    if(i>=0) arr[i]=lesson; else arr.push(lesson);
    qSaveAll(arr);
}

// sidebar integration
function ensureCustomModule(){
    let sec=document.querySelector('#custom-module');
    if(!sec){
        const aside=document.querySelector('#sidebar-left');
        const wrap=document.createElement('div');
        wrap.className='module-section'; wrap.id='custom-module';
        wrap.innerHTML = '<h3>Custom</h3><div id="custom-list"></div>';
        aside.appendChild(wrap);
    }
}
function addCustomLessonToSidebar(lesson){
    ensureCustomModule();
    const list=document.querySelector('#custom-list');
    const el=document.createElement('div');
    el.className='lesson-item'; el.dataset.lesson=lesson.id;
    el.textContent=`${lesson.id} ${lesson.title}`;
    el.addEventListener('click',()=>runCmd(`load ${lesson.id}`));
    list.appendChild(el);
}

function loadCustomLessonsFromLS(){
    const arr=qLoadAll();
    arr.forEach(l=>{ Lessons[l.id]=l; addCustomLessonToSidebar(l); });
    updateLessonProgress();
}
// modal bindings
function qoderInitUI(){
    const openBtn=document.getElementById('open-qoder');
    const modal=document.getElementById('qoder-modal');
    const closeBtn=document.getElementById('qoder-close');
    const tSel=document.getElementById('q-template');
    const pBox=document.getElementById('q-params');
    const out=document.getElementById('q-output');

    function renderParams(){
        pBox.innerHTML='';
        const t=Qoder.templates[tSel.value];
        t.params.forEach(par=>{
            const w=document.createElement('div'); w.style.display='flex'; w.style.flexDirection='column';
            const lab=document.createElement('div'); lab.style.color='var(--muted)'; lab.style.fontSize='12px'; lab.textContent=par.label;
            const inp=document.createElement('input'); inp.value=par.def||''; inp.id='qpar-'+par.key;
            Object.assign(inp.style,{background:'rgba(255,255,255,0.04)',border:'1px solid #243140',borderRadius:'8px',color:'var(--ink)',padding:'8px 10px',fontFamily:'var(--mono)',fontSize:'12px'});
            w.appendChild(lab); w.appendChild(inp); pBox.appendChild(w);
        });
    }

    function collectParams(){
        const t=Qoder.templates[tSel.value];
        const params={};
        t.params.forEach(par=>{
            params[par.key]=document.getElementById('qpar-'+par.key).value.trim();
        });
        return params;
    }

    function buildLesson(){
        const id=document.getElementById('q-id').value.trim();
        const title=document.getElementById('q-title').value.trim();
        const tpl=Qoder.templates[tSel.value];
        const lesson=tpl.build(collectParams());
        if(id) lesson.id=id; else lesson.id = suggestId();
        if(title) lesson.title=title;
        return lesson;
    }

    function suggestId(){
        // –Ω–∞–π–¥—ë–º —Å–ª–µ–¥—É—é—â–∏–π —Å–≤–æ–±–æ–¥–Ω—ã–π X.Y (–Ω–∞—á–Ω—ë–º —Å 3.1)
        let baseX=3, y=1;
        while(Lessons[`${baseX}.${y}`]) y++;
        return `${baseX}.${y}`;
    }

    openBtn.addEventListener('click',()=>{ modal.classList.remove('hidden'); renderParams(); out.textContent=''; });
    closeBtn.addEventListener('click',()=>modal.classList.add('hidden'));
    tSel.addEventListener('change',renderParams);

    document.getElementById('q-preview').addEventListener('click',()=>{
        const lesson=buildLesson();
        out.textContent = JSON.stringify(lesson,null,2);
    });

    document.getElementById('q-insert').addEventListener('click',()=>{
        const lesson=buildLesson();
        Lessons[lesson.id]=lesson;
        qUpsert(lesson);
        addCustomLessonToSidebar(lesson);
        updateLessonProgress();
        print(`Qoder: inserted lesson ${lesson.id} ‚Äî ${lesson.title}`);
    });

    // export/import custom lessons
    document.getElementById('q-export').addEventListener('click', ()=>{
        const data = JSON.stringify(qLoadAll(), null, 2);
        const blob = new Blob([data], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download='qoder_lessons.json'; a.click();
        URL.revokeObjectURL(url);
    });

    document.getElementById('q-import').addEventListener('click', ()=>{
        const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.onchange = (e)=>{
            const file=e.target.files[0]; const fr=new FileReader();
            fr.onload=()=>{
                try{
                    const arr=JSON.parse(fr.result);
                    if(Array.isArray(arr)){
                        qSaveAll(arr);
                        // –ø–µ—Ä–µ—Ä–∏—Å—É–µ–º custom-list
                        ensureCustomModule(); document.getElementById('custom-list').innerHTML='';
                        arr.forEach(l=>{ Lessons[l.id]=l; addCustomLessonToSidebar(l); });
                        updateLessonProgress();
                        print(`Qoder: imported ${arr.length} custom lessons`);
                    }
                }catch(err){ print('Qoder import error: '+err.message); }
            };
            fr.readAsText(file);
        };
        inp.click();
    });
}

// Global State & Data
const State = {
    currentLesson: null, ipIndex: 0,
    regs: { rax: 0n, rbx: 0n, rcx: 0n, rdx: 0n, rsi: 0n, rdi: 0n, rbp: 0x7fffffffe000n, rsp: 0x7fffffffe000n, rip: 0x401000n },
    flags: { zf: 0, sf: 0, of: 0, cf: 0 }, stack: [], breakpoints: [], hits: [], activeTab: 'disasm', progress: {},
    commandHistory: [], historyIndex: -1
};

// Lessons Database - Detailed explanations for beginners
const Lessons = {
    '0.1': {
        id: '0.1', title: 'üöÄ Hello, World - Your First Steps',
        goal: 'Execute 3 steps and reach the ret instruction to complete the function',
        hint: 'Use "si" command or press F10 to step through each instruction one by one',
        explanation: `Welcome to assembly! Every function starts with a prologue (setup) and ends with epilogue (cleanup):
‚Ä¢ push rbp - Save the old frame pointer
‚Ä¢ mov rbp, rsp - Set up new frame pointer
‚Ä¢ leave - Restore the old frame (same as mov rsp,rbp + pop rbp)
‚Ä¢ ret - Return to caller`,
        base: 0x401000,
        strings: ['Hello, World!'],
        disasm: [
            { a: 0x401000, b: '55', s: 'push rbp' },
            { a: 0x401001, b: '48 89 e5', s: 'mov rbp, rsp' },
            { a: 0x401004, b: 'c9', s: 'leave' },
            { a: 0x401005, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 150, y: 100, width: 140, height: 80, instrs: [0, 1, 2, 3], label: 'Function prologue\npush rbp\nmov rbp, rsp\nleave\nret' }
            ],
            edges: []
        },
        trace: [
            { ip: 0, regs: { rsp: 0x7fffffffdf8n }, note: 'Pushed RBP onto stack, RSP decreased by 8' },
            { ip: 1, regs: { rbp: 0x7fffffffe000n }, note: 'RBP now points to current stack frame' },
            { ip: 2, regs: { rsp: 0x7fffffffe000n }, note: 'Stack restored to original state' },
            { ip: 3, note: 'Function is ready to return to caller' }
        ],
        check: s => s.ipIndex >= 3
    },
    '0.2': {
        id: '0.2', title: 'üßÆ MOV & ADD - Basic Math',
        goal: 'Make RAX equal to 0x37 (which is 55 in decimal)',
        hint: 'Watch how MOV puts a value into RAX, then ADD increases it',
        explanation: `Assembly math is simple!
‚Ä¢ MOV copies a value: mov rax, 0x10 puts 16 into RAX register
‚Ä¢ ADD adds to existing value: add rax, 0x27 adds 39 to whatever is in RAX
‚Ä¢ Result: 16 + 39 = 55 (0x37 in hex)`,
        base: 0x401000,
        strings: ['Math: 16 + 39 = 55'],
        disasm: [
            { a: 0x401000, b: '48 c7 c0 10 00 00 00', s: 'mov rax, 0x10' },
            { a: 0x401007, b: '48 83 c0 27', s: 'add rax, 0x27' },
            { a: 0x40100b, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 150, y: 100, width: 120, height: 60, instrs: [0, 1, 2], label: 'Arithmetic\nmov rax, 0x10\nadd rax, 0x27\nret' }
            ],
            edges: []
        },
        trace: [
            { ip: 0, regs: { rax: 0x10n }, note: 'RAX now contains 16 (0x10)' },
            { ip: 1, regs: { rax: 0x37n }, note: 'RAX = 16 + 39 = 55 (0x37)' },
            { ip: 2, note: 'Math complete! RAX holds our result' }
        ],
        check: s => s.regs.rax === 0x37n
    },
    '0.3': {
        id: '0.3', title: 'üíæ Memory Operations - Stack Storage',
        goal: 'Store the value 42 at [rbp-8] and then read it back into RAX',
        hint: 'First MOV stores to memory, second MOV reads from memory',
        explanation: `Memory addressing in assembly:
‚Ä¢ [rbp-8] means "8 bytes before RBP on the stack"
‚Ä¢ This creates a local variable space
‚Ä¢ First we store 42 there, then read it back to prove it worked`,
        base: 0x401000,
        strings: ['Local variable: 42'],
        disasm: [
            { a: 0x401000, b: '48 c7 45 f8 2a 00 00 00', s: 'mov QWORD PTR [rbp-0x8], 0x2a' },
            { a: 0x401008, b: '48 8b 45 f8', s: 'mov rax, QWORD PTR [rbp-0x8]' },
            { a: 0x40100c, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 100, y: 100, width: 180, height: 60, instrs: [0, 1, 2], label: 'Memory operations\nmov [rbp-8], 0x2a\nmov rax, [rbp-8]\nret' }
            ],
            edges: []
        },
        trace: [
            { ip: 0, stack: [0x2an], note: 'Stored 42 (0x2a) at stack location [rbp-8]' },
            { ip: 1, regs: { rax: 0x2an }, note: 'Read the value back from memory into RAX' },
            { ip: 2, note: 'Successfully demonstrated memory read/write!' }
        ],
        check: s => s.regs.rax === 0x2an
    },
    '1.1': {
        id: '1.1', title: 'üîÄ Conditional Jumps - Making Decisions',
        goal: 'Follow the correct branch to make RAX equal 0x42',
        hint: 'The CMP instruction sets flags, then JZ (jump if zero) decides which path to take',
        explanation: `Conditional jumps let programs make decisions:
‚Ä¢ CMP compares two values and sets flags
‚Ä¢ JZ jumps if the values were equal (zero flag set)
‚Ä¢ JNZ jumps if the values were different
‚Ä¢ This is how if/else works in assembly!`,
        base: 0x401000,
        disasm: [
            { a: 0x401000, b: '48 83 f9 00', s: 'cmp rcx, 0x0' },
            { a: 0x401004, b: '74 08', s: 'jz 0x40100e' },
            { a: 0x401006, b: '48 c7 c0 99 00 00 00', s: 'mov rax, 0x99' },
            { a: 0x40100d, b: 'c3', s: 'ret' },
            { a: 0x40100e, b: '48 c7 c0 42 00 00 00', s: 'mov rax, 0x42' },
            { a: 0x401015, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 50, y: 50, width: 120, height: 60, instrs: [0, 1], label: 'Entry\ncmp rcx, 0\njz B2' },
                { id: 'B1', x: 50, y: 200, width: 120, height: 40, instrs: [2, 3], label: 'False branch\nmov rax, 0x99\nret' },
                { id: 'B2', x: 250, y: 200, width: 120, height: 40, instrs: [4, 5], label: 'True branch\nmov rax, 0x42\nret' }
            ],
            edges: [
                { from: 'B0', to: 'B1', type: 'fall', label: 'ZF=0' },
                { from: 'B0', to: 'B2', type: 'branch', label: 'ZF=1' }
            ]
        },
        trace: [
            { ip: 0, flags: { zf: 1 }, note: 'Compared RCX with 0, they are equal so ZF=1' },
            { ip: 1, note: 'ZF is 1, so we take the jump to address 0x40100e' },
            { ip: 4, regs: { rax: 0x42n }, note: 'We took the "true" branch and set RAX to 0x42' },
            { ip: 5, note: 'Mission accomplished!' }
        ],
        check: s => s.regs.rax === 0x42n
    },
    '1.2': {
        id: '1.2', title: 'üîÑ Loops - Counting Down',
        goal: 'Count RCX down from 3 to 0 using a loop',
        hint: 'DEC decreases RCX by 1, JNZ jumps back if RCX is not zero',
        explanation: `Loops repeat code until a condition is met:
‚Ä¢ Start with RCX = 3 (our counter)
‚Ä¢ DEC rcx subtracts 1 from RCX
‚Ä¢ JNZ jumps back to the DEC if RCX ‚â† 0
‚Ä¢ When RCX reaches 0, we exit the loop`,
        base: 0x401000,
        strings: ['Loop counter from 3 to 0'],
        disasm: [
            { a: 0x401000, b: '48 c7 c1 03 00 00 00', s: 'mov rcx, 0x3' },
            { a: 0x401007, b: '48 ff c9', s: 'dec rcx' },
            { a: 0x40100a, b: '75 fb', s: 'jnz 0x401007' },
            { a: 0x40100c, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 50, y: 50, width: 120, height: 40, instrs: [0], label: 'Init\nmov rcx, 3' },
                { id: 'B1', x: 50, y: 150, width: 120, height: 60, instrs: [1, 2], label: 'Loop body\ndec rcx\njnz B1' },
                { id: 'B2', x: 250, y: 200, width: 80, height: 40, instrs: [3], label: 'Exit\nret' }
            ],
            edges: [
                { from: 'B0', to: 'B1', type: 'fall', label: '' },
                { from: 'B1', to: 'B1', type: 'branch', label: 'RCX‚â†0' },
                { from: 'B1', to: 'B2', type: 'fall', label: 'RCX=0' }
            ]
        },
        trace: [
            { ip: 0, regs: { rcx: 0x3n }, note: 'Initialize counter to 3' },
            { ip: 1, regs: { rcx: 0x2n }, flags: { zf: 0 }, note: 'RCX = 2, not zero so ZF=0' },
            { ip: 2, note: 'ZF=0, jump back to DEC (loop continues)' },
            { ip: 1, regs: { rcx: 0x1n }, flags: { zf: 0 }, note: 'RCX = 1, still not zero' },
            { ip: 2, note: 'Jump back again' },
            { ip: 1, regs: { rcx: 0x0n }, flags: { zf: 1 }, note: 'RCX = 0, zero flag is set!' },
            { ip: 2, note: 'ZF=1, no jump - we exit the loop' },
            { ip: 3, note: 'Loop finished, RCX is now 0' }
        ],
        check: s => s.regs.rcx === 0x0n
    },
    '1.3': {
        id: '1.3', title: 'üìù String Length - Finding the End',
        goal: 'Find the length of the string "hello" (should be 5)',
        hint: 'Loop through each character until you find the null terminator (0)',
        explanation: `String processing in assembly:
‚Ä¢ Strings end with null byte (0)
‚Ä¢ Load each character with MOV AL (8-bit)
‚Ä¢ TEST AL, AL checks if character is 0
‚Ä¢ If not 0, increment counter and continue
‚Ä¢ If 0, we found the end!`,
        base: 0x401000,
        strings: ['hello'],
        disasm: [
            { a: 0x401000, b: '48 c7 c6 20 10 40 00', s: 'mov rsi, 0x401020' },
            { a: 0x401007, b: '48 31 c9', s: 'xor rcx, rcx' },
            { a: 0x40100a, b: '8a 04 0e', s: 'mov al, BYTE PTR [rsi+rcx]' },
            { a: 0x40100d, b: '84 c0', s: 'test al, al' },
            { a: 0x40100f, b: '74 06', s: 'jz 0x401017' },
            { a: 0x401011, b: '48 ff c1', s: 'inc rcx' },
            { a: 0x401014, b: 'eb f4', s: 'jmp 0x40100a' },
            { a: 0x401017, b: 'c3', s: 'ret' }
        ],
        trace: [
            { ip: 0, regs: { rsi: 0x401020n }, note: 'RSI points to string "hello"' },
            { ip: 1, regs: { rcx: 0x0n }, note: 'RCX = 0 (our length counter)' },
            { ip: 2, regs: { rax: 0x68n }, note: 'AL = h (0x68), first character' },
            { ip: 3, flags: { zf: 0 }, note: 'Character is not 0, continue' },
            { ip: 4, note: 'Not zero, skip the exit jump' },
            { ip: 5, regs: { rcx: 0x1n }, note: 'Increment counter: length = 1' },
            { ip: 6, note: 'Jump back to check next character' },
            { ip: 2, regs: { rax: 0x65n }, note: 'AL = e (0x65), second character' },
            { ip: 3, flags: { zf: 0 }, note: 'Still not 0' },
            { ip: 5, regs: { rcx: 0x2n }, note: 'Length = 2' },
            { ip: 2, regs: { rax: 0x6cn }, note: 'AL = l (0x6c)' },
            { ip: 5, regs: { rcx: 0x3n }, note: 'Length = 3' },
            { ip: 2, regs: { rax: 0x6cn }, note: 'AL = l (0x6c) again' },
            { ip: 5, regs: { rcx: 0x4n }, note: 'Length = 4' },
            { ip: 2, regs: { rax: 0x6fn }, note: 'AL = o (0x6f)' },
            { ip: 5, regs: { rcx: 0x5n }, note: 'Length = 5' },
            { ip: 2, regs: { rax: 0x0n }, note: 'AL = 0 (null terminator found!)' },
            { ip: 3, flags: { zf: 1 }, note: 'Zero flag set - end of string!' },
            { ip: 4, note: 'Take the jump to exit' },
            { ip: 7, note: 'String length is 5 characters' }
        ],
        check: s => s.regs.rcx === 0x5n
    },
    '1.4': {
        id: '1.4', title: 'üßÆ Checksum - Array Sum',
        goal: 'Sum all bytes in the array [1,2,3,4] to get 10 in RAX',
        hint: 'Loop through each byte, add it to RAX, increment the index',
        explanation: `Array processing pattern:
‚Ä¢ RSI points to array start
‚Ä¢ RCX is our index (0,1,2,3)
‚Ä¢ Load byte with [rsi+rcx]
‚Ä¢ Add to running sum in RAX
‚Ä¢ Continue until all bytes processed`,
        base: 0x401000,
        strings: ['Array data: [1,2,3,4]'],
        disasm: [
            { a: 0x401000, b: '48 c7 c6 20 10 40 00', s: 'mov rsi, 0x401020' },
            { a: 0x401007, b: '48 31 c0', s: 'xor rax, rax' },
            { a: 0x40100a, b: '48 31 c9', s: 'xor rcx, rcx' },
            { a: 0x40100d, b: '8a 14 0e', s: 'mov dl, BYTE PTR [rsi+rcx]' },
            { a: 0x401010, b: '48 01 d0', s: 'add rax, rdx' },
            { a: 0x401013, b: '48 ff c1', s: 'inc rcx' },
            { a: 0x401016, b: '48 83 f9 04', s: 'cmp rcx, 4' },
            { a: 0x40101a, b: '75 f1', s: 'jne 0x40100d' },
            { a: 0x40101c, b: 'c3', s: 'ret' }
        ],
        trace: [
            { ip: 0, regs: { rsi: 0x401020n }, note: 'RSI points to array [1,2,3,4]' },
            { ip: 1, regs: { rax: 0x0n }, note: 'Clear RAX (our sum)' },
            { ip: 2, regs: { rcx: 0x0n }, note: 'Clear RCX (our index)' },
            { ip: 3, regs: { rdx: 0x1n }, note: 'Load array[0] = 1' },
            { ip: 4, regs: { rax: 0x1n }, note: 'Sum = 0 + 1 = 1' },
            { ip: 5, regs: { rcx: 0x1n }, note: 'Index = 1' },
            { ip: 6, flags: { zf: 0 }, note: 'Compare: 1 != 4, continue' },
            { ip: 7, note: 'Jump back to load next byte' },
            { ip: 3, regs: { rdx: 0x2n }, note: 'Load array[1] = 2' },
            { ip: 4, regs: { rax: 0x3n }, note: 'Sum = 1 + 2 = 3' },
            { ip: 5, regs: { rcx: 0x2n }, note: 'Index = 2' },
            { ip: 7, note: 'Continue loop...' },
            { ip: 3, regs: { rdx: 0x3n }, note: 'Load array[2] = 3' },
            { ip: 4, regs: { rax: 0x6n }, note: 'Sum = 3 + 3 = 6' },
            { ip: 5, regs: { rcx: 0x3n }, note: 'Index = 3' },
            { ip: 7, note: 'Continue loop...' },
            { ip: 3, regs: { rdx: 0x4n }, note: 'Load array[3] = 4' },
            { ip: 4, regs: { rax: 0xan }, note: 'Sum = 6 + 4 = 10 (final!)' },
            { ip: 5, regs: { rcx: 0x4n }, note: 'Index = 4' },
            { ip: 6, flags: { zf: 1 }, note: 'Compare: 4 == 4, exit loop' },
            { ip: 7, note: 'No jump, fall through' },
            { ip: 8, note: 'Array sum complete: 1+2+3+4=10' }
        ],
        check: s => s.regs.rax === 0xan
    },
    '1.5': {
        id: '1.5', title: 'üîÄ Switch Statement - Jump Tables',
        goal: 'Execute case 2 of the switch to get RAX = 0x222',
        hint: 'RDI contains the switch value (2), jump table selects the right case',
        explanation: `Switch statements use jump tables:
‚Ä¢ RDI = switch value (0, 1, 2, or 3)
‚Ä¢ Jump table at 0x401040 has 4 addresses
‚Ä¢ JMP [table + value*8] jumps to case
‚Ä¢ Much faster than multiple if/else chains!`,
        base: 0x401000,
        disasm: [
            { a: 0x401000, b: '48 c7 c7 02 00 00 00', s: 'mov rdi, 2' },
            { a: 0x401007, b: '48 83 ff 03', s: 'cmp rdi, 3' },
            { a: 0x40100b, b: '77 13', s: 'ja 0x401020' },
            { a: 0x40100d, b: 'ff 24 fd 40 10 40 00', s: 'jmp QWORD PTR [rdi*8+0x401040]' },
            { a: 0x401014, b: '48 c7 c0 00 01 00 00', s: 'mov rax, 0x100' },
            { a: 0x40101b, b: 'c3', s: 'ret' },
            { a: 0x40101c, b: '48 c7 c0 11 01 00 00', s: 'mov rax, 0x111' },
            { a: 0x401023, b: 'c3', s: 'ret' },
            { a: 0x401024, b: '48 c7 c0 22 02 00 00', s: 'mov rax, 0x222' },
            { a: 0x40102b, b: 'c3', s: 'ret' },
            { a: 0x40102c, b: '48 c7 c0 33 03 00 00', s: 'mov rax, 0x333' },
            { a: 0x401033, b: 'c3', s: 'ret' },
            { a: 0x401020, b: '48 c7 c0 ff ff ff ff', s: 'mov rax, 0xffffffff' },
            { a: 0x401027, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 150, y: 30, width: 140, height: 80, instrs: [0, 1, 2, 3], label: 'Switch setup\nmov rdi, 2\ncmp rdi, 3\nja default\njmp [table+rdi*8]' },
                { id: 'B1', x: 30, y: 200, width: 100, height: 40, instrs: [4, 5], label: 'Case 0\nmov rax, 0x100' },
                { id: 'B2', x: 150, y: 200, width: 100, height: 40, instrs: [6, 7], label: 'Case 1\nmov rax, 0x111' },
                { id: 'B3', x: 270, y: 200, width: 100, height: 40, instrs: [8, 9], label: 'Case 2\nmov rax, 0x222' },
                { id: 'B4', x: 390, y: 200, width: 100, height: 40, instrs: [10, 11], label: 'Case 3\nmov rax, 0x333' },
                { id: 'B5', x: 520, y: 120, width: 100, height: 40, instrs: [12, 13], label: 'Default\nmov rax, -1' }
            ],
            edges: [
                { from: 'B0', to: 'B1', type: 'branch', label: 'rdi=0' },
                { from: 'B0', to: 'B2', type: 'branch', label: 'rdi=1' },
                { from: 'B0', to: 'B3', type: 'branch', label: 'rdi=2' },
                { from: 'B0', to: 'B4', type: 'branch', label: 'rdi=3' },
                { from: 'B0', to: 'B5', type: 'branch', label: 'rdi>3' }
            ]
        },
        trace: [
            { ip: 0, regs: { rdi: 0x2n }, note: 'Set switch value to 2' },
            { ip: 1, flags: { zf: 0 }, note: 'Compare 2 with 3: not equal' },
            { ip: 2, note: '2 <= 3, so no jump to default case' },
            { ip: 3, note: 'Jump to [0x401040 + 2*8] = case 2 handler' },
            { ip: 8, regs: { rax: 0x222n }, note: 'Execute case 2: RAX = 0x222' },
            { ip: 9, note: 'Switch statement complete!' }
        ],
        check: s => s.regs.rax === 0x222n
    },
    '2.1': {
        id: '2.1', title: 'üìû Calling Convention - Function Arguments',
        goal: 'Execute the function with arguments in RDI and RSI to get their sum in RAX',
        hint: 'System V AMD64 calling convention uses RDI, RSI, RDX, RCX for first 4 arguments',
        explanation: `System V AMD64 calling convention:
‚Ä¢ First 6 integer arguments: RDI, RSI, RDX, RCX, R8, R9
‚Ä¢ Return value goes in RAX
‚Ä¢ Caller saves: RAX, RCX, RDX, RSI, RDI, R8-R11
‚Ä¢ Callee saves: RBX, RBP, R12-R15
‚Ä¢ This function: int add(int a, int b) - a in RDI, b in RSI`,
        base: 0x401000,
        strings: ['add_function', 'System V ABI'],
        disasm: [
            { a: 0x401000, b: '55', s: 'push rbp' },
            { a: 0x401001, b: '48 89 e5', s: 'mov rbp, rsp' },
            { a: 0x401004, b: '48 89 7d f8', s: 'mov QWORD PTR [rbp-0x8], rdi' },
            { a: 0x401008, b: '48 89 75 f0', s: 'mov QWORD PTR [rbp-0x10], rsi' },
            { a: 0x40100c, b: '48 8b 45 f8', s: 'mov rax, QWORD PTR [rbp-0x8]' },
            { a: 0x401010, b: '48 03 45 f0', s: 'add rax, QWORD PTR [rbp-0x10]' },
            { a: 0x401014, b: '5d', s: 'pop rbp' },
            { a: 0x401015, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 100, y: 100, width: 160, height: 100, instrs: [0, 1, 2, 3, 4, 5, 6, 7], label: 'add(a, b)\npush rbp\nmov rbp, rsp\nsave RDI, RSI\nadd them\nreturn sum' }
            ],
            edges: []
        },
        trace: [
            { ip: 0, regs: { rsp: 0x7fffffffdf8n, rdi: 0x10n, rsi: 0x20n }, note: 'Function called with args: RDI=16, RSI=32' },
            { ip: 1, regs: { rbp: 0x7fffffffe000n }, note: 'Set up stack frame' },
            { ip: 2, stack: [0x10n], note: 'Save first argument (RDI=16) to local variable' },
            { ip: 3, stack: [0x10n, 0x20n], note: 'Save second argument (RSI=32) to local variable' },
            { ip: 4, regs: { rax: 0x10n }, note: 'Load first argument into RAX' },
            { ip: 5, regs: { rax: 0x30n }, note: 'Add second argument: 16 + 32 = 48' },
            { ip: 6, regs: { rbp: 0x7fffffffe000n }, note: 'Restore caller frame' },
            { ip: 7, note: 'Return with result 48 in RAX' }
        ],
        check: s => s.regs.rax === 0x30n
    },
    '2.2': {
        id: '2.2', title: 'üîó PLT/GOT - Dynamic Linking',
        goal: 'Call puts function through PLT and understand dynamic linking',
        hint: 'PLT (Procedure Linkage Table) redirects to GOT (Global Offset Table) for dynamic functions',
        explanation: `Dynamic linking with PLT/GOT:
‚Ä¢ PLT entry jumps to address stored in GOT
‚Ä¢ First call: GOT contains resolver, loads real function address
‚Ä¢ Subsequent calls: GOT contains actual function address
‚Ä¢ puts@plt calls the puts library function
‚Ä¢ This enables loading libraries at runtime`,
        base: 0x401000,
        strings: ['Hello from puts!', 'puts@plt', 'libc.so.6'],
        disasm: [
            { a: 0x401000, b: '48 c7 c7 10 20 40 00', s: 'mov rdi, 0x402010' },
            { a: 0x401007, b: 'e8 04 00 00 00', s: 'call 0x401010' },
            { a: 0x40100c, b: 'c3', s: 'ret' },
            { a: 0x401010, b: 'ff 25 02 2f 00 00', s: 'jmp QWORD PTR [rip+0x2f02]' },
            { a: 0x401016, b: '68 00 00 00 00', s: 'push 0x0' },
            { a: 0x40101b, b: 'e9 e0 fe ff ff', s: 'jmp 0x401000' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 50, y: 50, width: 120, height: 60, instrs: [0, 1, 2], label: 'Main\nmov rdi, string\ncall puts@plt\nret' },
                { id: 'B1', x: 250, y: 50, width: 140, height: 80, instrs: [3, 4, 5], label: 'puts@plt\njmp [GOT]\npush index\njmp resolver' }
            ],
            edges: [
                { from: 'B0', to: 'B1', type: 'call', label: 'call' }
            ]
        },
        trace: [
            { ip: 0, regs: { rdi: 0x402010n }, note: 'RDI points to string "Hello from puts!"' },
            { ip: 1, note: 'Call puts@plt (PLT entry for puts function)' },
            { ip: 3, note: 'PLT jumps to GOT entry for puts' },
            { ip: 4, note: 'First call: push symbol index for resolver' },
            { ip: 5, note: 'Jump to dynamic linker resolver' },
            { ip: 2, note: 'Return from puts (after string printed)' }
        ],
        check: s => s.ipIndex >= 2
    },
    '2.3': {
        id: '2.3', title: 'üõ°Ô∏è Stack Canary - Buffer Protection',
        goal: 'Execute the function and verify the stack canary protection works',
        hint: 'Watch how the canary is loaded at start and checked before return',
        explanation: `Stack canaries prevent buffer overflow attacks:
‚Ä¢ fs:[0x28] loads a random canary value from Thread Local Storage
‚Ä¢ Store canary on stack at function entry
‚Ä¢ Before return, compare with original value
‚Ä¢ If they don't match, the stack was corrupted (buffer overflow)
‚Ä¢ call __stack_chk_fail aborts the program for security`,
        base: 0x401000,
        strings: ['Stack canary protection', '__stack_chk_fail'],
        disasm: [
            { a: 0x401000, b: '55', s: 'push rbp' },
            { a: 0x401001, b: '48 89 e5', s: 'mov rbp, rsp' },
            { a: 0x401004, b: '48 83 ec 20', s: 'sub rsp, 0x20' },
            { a: 0x401008, b: '64 48 8b 04 25 28 00 00 00', s: 'mov rax, QWORD PTR fs:0x28' },
            { a: 0x401011, b: '48 89 45 f8', s: 'mov QWORD PTR [rbp-0x8], rax' },
            { a: 0x401015, b: '31 c0', s: 'xor eax, eax' },
            { a: 0x401017, b: '48 8b 45 f8', s: 'mov rax, QWORD PTR [rbp-0x8]' },
            { a: 0x40101b, b: '64 48 33 04 25 28 00 00 00', s: 'xor rax, QWORD PTR fs:0x28' },
            { a: 0x401024, b: '74 05', s: 'je 0x40102b' },
            { a: 0x401026, b: 'e8 00 00 00 00', s: 'call __stack_chk_fail' },
            { a: 0x40102b, b: 'c9', s: 'leave' },
            { a: 0x40102c, b: 'c3', s: 'ret' }
        ],
        trace: [
            { ip: 0, regs: { rsp: 0x7ffffffffdf8n }, note: 'Save old frame pointer' },
            { ip: 1, regs: { rbp: 0x7fffffffe000n }, note: 'Set up new frame pointer' },
            { ip: 2, regs: { rsp: 0x7ffffffffde0n }, note: 'Allocate 32 bytes for local variables' },
            { ip: 3, regs: { rax: 0x1234567890abcdefn }, note: 'Load stack canary from Thread Local Storage' },
            { ip: 4, stack: [0x1234567890abcdefn], note: 'Store canary at [rbp-8] to guard the stack' },
            { ip: 5, regs: { rax: 0x0n }, note: 'Clear RAX for function body (simulated work)' },
            { ip: 6, regs: { rax: 0x1234567890abcdefn }, note: 'Load stored canary value for verification' },
            { ip: 7, regs: { rax: 0x0n }, flags: { zf: 1 }, note: 'XOR with original canary - result is 0 (no corruption!)' },
            { ip: 8, note: 'Canaries match (ZF=1), skip security abort' },
            { ip: 10, regs: { rsp: 0x7fffffffe000n }, note: 'Restore stack and frame pointer' },
            { ip: 11, note: 'Safe return - stack integrity verified!' }
        ],
        check: s => s.ipIndex >= 10 && s.flags.zf === 1
    },
    '2.4': {
        id: '2.4', title: 'üß† Compiler Idioms - Optimized Patterns',
        goal: 'Recognize the optimized memset pattern that clears 16 bytes',
        hint: 'REP STOSQ is an optimized way to fill memory - much faster than a loop',
        explanation: `Compilers generate optimized code patterns:
‚Ä¢ memset(ptr, 0, 16) becomes REP STOSQ
‚Ä¢ REP prefix repeats the STOSQ instruction RCX times
‚Ä¢ STOSQ stores RAX to [RDI] and increments RDI by 8
‚Ä¢ This clears 16 bytes (2 √ó 8-byte stores) very efficiently
‚Ä¢ Much faster than manual loop with individual MOV instructions`,
        base: 0x401000,
        strings: ['memset optimization', 'REP STOSQ pattern'],
        disasm: [
            { a: 0x401000, b: '48 c7 c7 00 20 40 00', s: 'mov rdi, 0x402000' },
            { a: 0x401007, b: '48 31 c0', s: 'xor rax, rax' },
            { a: 0x40100a, b: '48 c7 c1 02 00 00 00', s: 'mov rcx, 2' },
            { a: 0x401011, b: 'f3 48 ab', s: 'rep stosq' },
            { a: 0x401014, b: 'c3', s: 'ret' }
        ],
        trace: [
            { ip: 0, regs: { rdi: 0x402000n }, note: 'RDI = destination pointer (where to write zeros)' },
            { ip: 1, regs: { rax: 0x0n }, note: 'RAX = 0 (the value to fill memory with)' },
            { ip: 2, regs: { rcx: 0x2n }, note: 'RCX = 2 (repeat count: 2 √ó 8 bytes = 16 bytes total)' },
            { ip: 3, regs: { rdi: 0x402010n, rcx: 0x0n }, note: 'REP STOSQ: stored 0 at [0x402000] and [0x402008], cleared 16 bytes!' },
            { ip: 4, note: 'Efficient memset complete - 16 bytes zeroed in 1 instruction!' }
        ],
        check: s => s.regs.rcx === 0x0n && s.regs.rdi === 0x402010n
    },
    '2.5': {
        id: '2.5', title: 'üîê XOR Crackme - Simple Encryption',
        goal: 'Decrypt the message by XORing with the key 0x42 to get result 0x33',
        hint: 'XOR is reversible: if A XOR B = C, then C XOR B = A',
        explanation: `XOR encryption basics (educational only):
‚Ä¢ XOR is a bitwise operation: 0‚äï0=0, 0‚äï1=1, 1‚äï0=1, 1‚äï1=0
‚Ä¢ XOR is its own inverse: (A ‚äï B) ‚äï B = A
‚Ä¢ Simple XOR cipher: plaintext ‚äï key = ciphertext
‚Ä¢ To decrypt: ciphertext ‚äï key = plaintext
‚Ä¢ Our encrypted byte 0x71 XOR key 0x42 = 0x33 (decrypted!)`,
        base: 0x401000,
        strings: ['Encrypted: 0x71', 'Key: 0x42', 'Decrypted: 0x33'],
        disasm: [
            { a: 0x401000, b: '48 c7 c0 71 00 00 00', s: 'mov rax, 0x71' },
            { a: 0x401007, b: '48 c7 c1 42 00 00 00', s: 'mov rcx, 0x42' },
            { a: 0x40100e, b: '48 31 c8', s: 'xor rax, rcx' },
            { a: 0x401011, b: '48 83 f8 33', s: 'cmp rax, 0x33' },
            { a: 0x401015, b: '74 05', s: 'jz 0x40101c' },
            { a: 0x401017, b: '48 c7 c0 ff ff ff ff', s: 'mov rax, -1' },
            { a: 0x40101e, b: 'c3', s: 'ret' },
            { a: 0x40101c, b: '48 c7 c0 01 00 00 00', s: 'mov rax, 1' },
            { a: 0x401023, b: 'c3', s: 'ret' }
        ],
        cfg: {
            blocks: [
                { id: 'B0', x: 50, y: 50, width: 140, height: 80, instrs: [0, 1, 2, 3, 4], label: 'Setup\nmov rax, 0x71\nmov rcx, 0x42\nxor rax, rcx\ncmp rax, 0x33\njz success' },
                { id: 'B1', x: 50, y: 200, width: 100, height: 40, instrs: [5, 6], label: 'Fail\nmov rax, -1\nret' },
                { id: 'B2', x: 250, y: 200, width: 100, height: 40, instrs: [7, 8], label: 'Success\nmov rax, 1\nret' }
            ],
            edges: [
                { from: 'B0', to: 'B1', type: 'fall', label: 'wrong' },
                { from: 'B0', to: 'B2', type: 'branch', label: 'correct' }
            ]
        },
        trace: [
            { ip: 0, regs: { rax: 0x71n }, note: 'RAX = 0x71 (encrypted message byte)' },
            { ip: 1, regs: { rcx: 0x42n }, note: 'RCX = 0x42 (XOR key for decryption)' },
            { ip: 2, regs: { rax: 0x33n }, note: 'XOR decrypt: 0x71 ‚äï 0x42 = 0x33 (ASCII "3")' },
            { ip: 3, flags: { zf: 1 }, note: 'Compare with expected value 0x33 - they match!' },
            { ip: 4, note: 'Equal comparison (ZF=1), take success branch' },
            { ip: 7, regs: { rax: 0x1n }, note: 'Decryption successful! RAX = 1 (success code)' },
            { ip: 8, note: 'Crackme solved - message decrypted correctly!' }
        ],
        check: s => s.regs.rax === 0x1n
    }
};

// Utilities
const hex = n => '0x' + Number(n).toString(16).padStart(16, '0');
const esc = s => String(s).replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));

function parseAddr(addrStr) {
    // Parse address from string (supports 0x prefix, $rip, etc)
    if (addrStr === '$rip') {
        return Number(State.regs.rip);
    }
    
    let addr;
    if (addrStr.startsWith('0x')) {
        addr = parseInt(addrStr, 16);
    } else {
        addr = parseInt(addrStr, 10);
    }
    
    return isNaN(addr) ? null : addr;
}

const LS = {
    get: (k, d = {}) => { try { return JSON.parse(localStorage.getItem(k)) ?? d; } catch (_) { return d; } },
    set: (k, v) => localStorage.setItem(k, JSON.stringify(v))
};

const loadProgress = () => LS.get('hl_progress_v2', {});
const saveProgress = (id, done) => { const p = loadProgress(); p[id] = {done}; LS.set('hl_progress_v2', p); State.progress = p; };

function print(msg) {
    const body = document.getElementById('term-body');
    body.innerHTML += `<div>${esc(msg)}</div>`;
    body.scrollTop = body.scrollHeight;
}

// Commands
const Commands = {
    help() {
        print('üöÄ Hacker Lab Commands - Interactive Assembly Debugger');
        print('');
        print('üìö LESSON MANAGEMENT:');
        print('  help           - Show this comprehensive help');
        print('  levels         - List all 13 available lessons');
        print('  load <id>      - Load lesson (e.g., load 0.1, load 2.5)');
        print('  goal           - Show current lesson objective');
        print('  hint           - Get a helpful hint for current lesson');
        print('  explain        - Detailed lesson explanation');
        print('  check          - Verify if lesson goal is achieved');
        print('  reset          - Reset current lesson to beginning');
        print('');
        print('üéÆ EXECUTION CONTROL:');
        print('  si             - Step instruction (also F10)');
        print('  c              - Continue execution until breakpoint (also F9)');
        print('  break <addr>   - Set breakpoint at address (e.g., break 0x401000)');
        print('  del <addr>     - Remove breakpoint at address');
        print('  bps            - List all active breakpoints');
        print('');
        print('üîç INSPECTION COMMANDS:');
        print('  regs           - Display all CPU registers');
        print('  stack          - Show stack contents (top 5 entries)');
        print('  flags          - Display CPU flags (ZF, SF, OF, CF)');
        print('  flow           - Switch to Control Flow Graph view');
        print('');
        print('üìä QUICK TIPS:');
        print('  ‚Ä¢ Use F10/F9 for faster stepping/running');
        print('  ‚Ä¢ Click on disassembly lines to set breakpoints');
        print('  ‚Ä¢ Check the "Lesson" tab for detailed explanations');
        print('  ‚Ä¢ Complete all 13 lessons to become an expert!');
        print('');
    },
    levels() {
        print('üìö Available lessons - Interactive Assembly & Reverse Engineering:');
        print('');
        print('üîµ Module 0: Orientation (Beginner)');
        ['0.1', '0.2', '0.3'].forEach(id => {
            const lesson = Lessons[id];
            const done = State.progress[id]?.done ? ' ‚úì' : '';
            const current = State.currentLesson?.id === id ? ' ‚û§' : '';
            print(`  ${id} - ${lesson.title}${done}${current}`);
        });
        
        print('');
        print('üü° Module 1: Control & Data (Intermediate)');
        ['1.1', '1.2', '1.3', '1.4', '1.5'].forEach(id => {
            const lesson = Lessons[id];
            const done = State.progress[id]?.done ? ' ‚úì' : '';
            const current = State.currentLesson?.id === id ? ' ‚û§' : '';
            print(`  ${id} - ${lesson.title}${done}${current}`);
        });
        
        print('');
        print('üî¥ Module 2: Advanced Topics (Expert)');
        ['2.1', '2.2', '2.3', '2.4', '2.5'].forEach(id => {
            const lesson = Lessons[id];
            const done = State.progress[id]?.done ? ' ‚úì' : '';
            const current = State.currentLesson?.id === id ? ' ‚û§' : '';
            print(`  ${id} - ${lesson.title}${done}${current}`);
        });
        
        const totalLessons = Object.keys(Lessons).length;
        const completedLessons = Object.values(State.progress).filter(p => p.done).length;
        print('');
        print(`üìä Progress: ${completedLessons}/${totalLessons} lessons completed (${Math.round((completedLessons / totalLessons) * 100)}%)`);
        
        if (completedLessons === totalLessons) {
            print('üèÜ CONGRATULATIONS! All lessons completed! You are now a certified expert!');
        } else {
            print(`üéØ Next: Try "load ${getNextLesson()}" to continue your journey!`);
        }
    },
    load(id) {
        if (!id) return print('Usage: load <lesson_id>');
        if (!Lessons[id]) return print(`Lesson ${id} not found`);
        loadLesson(id);
        print(`Loaded lesson ${id}: ${Lessons[id].title}`);
    },
    si() { step(); },
    c() { continue_exec(); },
    regs() {
        print('Registers:');
        Object.entries(State.regs).forEach(([k, v]) => print(`  ${k.toUpperCase()}: ${hex(v)}`));
    },
    stack() {
        print('Stack (top 5):');
        for (let i = 0; i < 5; i++) {
            const addr = State.regs.rsp + BigInt(i * 8);
            const val = State.stack[i] || 0n;
            print(`  ${hex(addr)}: ${hex(val)}`);
        }
    },
    flags() {
        const f = State.flags;
        print(`Flags: ZF=${f.zf} SF=${f.sf} OF=${f.of} CF=${f.cf}`);
    },
    goal() {
        if (!State.currentLesson) return print('No lesson loaded');
        print(`Goal: ${State.currentLesson.goal}`);
    },
    hint() {
        if (!State.currentLesson) return print('No lesson loaded');
        print(`Hint: ${State.currentLesson.hint}`);
    },
    
    explain() {
        if (!State.currentLesson) return print('No lesson loaded');
        if (!State.currentLesson.explanation) return print('No detailed explanation available for this lesson');
        print('üí° Detailed Explanation:');
        const lines = State.currentLesson.explanation.split('\n');
        lines.forEach(line => {
            if (line.trim()) print(`  ${line.trim()}`);
        });
    },
    check() {
        if (!State.currentLesson) return print('No lesson loaded');
        const result = State.currentLesson.check(State);
        if (result) {
            print('‚úì PASS - Lesson completed! üéÜ');
            saveProgress(State.currentLesson.id, true);
            updateLessonProgress();
            showSuccessAnimation();
            
            // Check if this completes a module
            const moduleComplete = checkModuleCompletion();
            if (moduleComplete) {
                print(`üèÜ MODULE ${moduleComplete} COMPLETED! All lessons in this module finished!`);
            }
            
            // Check if all lessons are complete
            const totalLessons = Object.keys(Lessons).length;
            const completedLessons = Object.values(State.progress).filter(p => p.done).length;
            if (completedLessons === totalLessons) {
                print('üèÜüéÜüèÜ CONGRATULATIONS! You\'ve completed ALL lessons in Hacker Lab! üèÜüéÜüèÜ');
                print('You are now a certified Assembly & Reverse Engineering expert!');
            }
        } else {
            print('‚úó FAIL - Keep trying! Use "hint" command for guidance.');
        }
    },
    reset() {
        if (!State.currentLesson) return print('No lesson loaded');
        State.ipIndex = 0; resetRegisters(); renderAll(); print('Lesson reset');
    },
    
    flow() {
        if (!State.currentLesson) return print('No lesson loaded');
        switchTab('flow');
        print('Switched to Control Flow Graph view');
    },
    
    break(addr) {
        if (!addr) return print('Usage: break <address>');
        const address = parseAddr(addr);
        if (address === null) return print('Invalid address format');
        
        if (State.breakpoints.includes(address)) {
            print(`Breakpoint already exists at ${hex(address)}`);
            return;
        }
        
        State.breakpoints.push(address);
        renderAll();
        print(`Breakpoint set at ${hex(address)}`);
    },
    
    del(addr) {
        if (!addr) return print('Usage: del <address>');
        const address = parseAddr(addr);
        if (address === null) return print('Invalid address format');
        
        const index = State.breakpoints.indexOf(address);
        if (index === -1) {
            print(`No breakpoint at ${hex(address)}`);
            return;
        }
        
        State.breakpoints.splice(index, 1);
        renderAll();
        print(`Breakpoint removed from ${hex(address)}`);
    },
    
    bps() {
        if (State.breakpoints.length === 0) {
            print('No breakpoints set');
            return;
        }
        
        print('Active breakpoints:');
        State.breakpoints.forEach((addr, i) => {
            print(`  [${i}] ${hex(addr)}`);
        });
    }
};

function runCmd(input) {
    if (!input.trim()) return;
    print(`(hlab)> ${input}`);
    
    // Add to command history
    if (State.commandHistory[State.commandHistory.length - 1] !== input) {
        State.commandHistory.push(input);
        // Keep only last 50 commands
        if (State.commandHistory.length > 50) {
            State.commandHistory.shift();
        }
    }
    State.historyIndex = -1;
    
    const [cmd, ...args] = input.trim().split(/\s+/);
    const fn = Commands[cmd];
    if (fn) { 
        fn(...args); 
    } else { 
        print(`Command not found: ${cmd}. Type 'help' for available commands.`);
        print(`Did you mean: ${getSuggestion(cmd)}?`);
    }
}

function getSuggestion(cmd) {
    const commands = Object.keys(Commands);
    const closest = commands.find(c => c.startsWith(cmd.substring(0, 2))) || 'help';
    return closest;
}

function getNextLesson() {
    const lessonOrder = ['0.1', '0.2', '0.3', '1.1', '1.2', '1.3', '1.4', '1.5', '2.1', '2.2', '2.3', '2.4', '2.5'];
    
    for (const id of lessonOrder) {
        if (!State.progress[id]?.done) {
            return id;
        }
    }
    
    return '0.1'; // If all complete, suggest first lesson
}

// Execution Engine
function step() {
    if (!State.currentLesson) return print('No lesson loaded');
    const trace = State.currentLesson.trace;
    if (State.ipIndex >= trace.length - 1) { print('End of trace'); return 'end'; }
    
    const step_data = trace[++State.ipIndex];
    if (step_data.regs) Object.assign(State.regs, mapBigInt(step_data.regs));
    if (step_data.flags) Object.assign(State.flags, step_data.flags);
    if (step_data.stack) State.stack = step_data.stack.slice();
    if (step_data.ip !== undefined) {
        const instr = State.currentLesson.disasm[step_data.ip];
        if (instr) State.regs.rip = BigInt(instr.a);
    }
    
    renderAll();
    
    // Check for breakpoints
    const currentAddr = Number(State.regs.rip);
    if (State.breakpoints.includes(currentAddr)) {
        State.hits.push(currentAddr);
        print(`üî¥ Breakpoint hit at ${hex(currentAddr)}!`);
        return 'break';
    }
    
    // Show detailed explanation for each step
    const stepMsg = `Step ${State.ipIndex}`;
    if (step_data.note) {
        print(`${stepMsg} - üìù ${step_data.note}`);
    } else {
        print(stepMsg);
    }
    
    return 'ok';
}

function continue_exec() {
    let steps = 0;
    while (State.ipIndex < State.currentLesson.trace.length - 1 && steps < 100) {
        const result = step();
        steps++;
        if (result === 'break') {
            print('Execution stopped at breakpoint');
            return;
        }
        if (result === 'end') {
            break;
        }
    }
    if (steps >= 100) print('Stopped after 100 steps');
}

function mapBigInt(obj) {
    const result = {};
    Object.entries(obj).forEach(([k, v]) => { result[k] = BigInt(v); });
    return result;
}

function resetRegisters() {
    State.regs = { rax: 0n, rbx: 0n, rcx: 0n, rdx: 0n, rsi: 0n, rdi: 0n, rbp: 0x7fffffffe000n, rsp: 0x7fffffffe000n, rip: 0x401000n };
    State.flags = { zf: 0, sf: 0, of: 0, cf: 0 };
}
function checkModuleCompletion() {
    const modules = {
        0: ['0.1', '0.2', '0.3'],
        1: ['1.1', '1.2', '1.3', '1.4', '1.5'],
        2: ['2.1', '2.2', '2.3', '2.4', '2.5']
    };
    
    for (const [moduleNum, lessons] of Object.entries(modules)) {
        const allComplete = lessons.every(id => State.progress[id]?.done);
        const justCompleted = lessons.includes(State.currentLesson.id) && State.progress[State.currentLesson.id]?.done;
        
        if (allComplete && justCompleted) {
            // Check if this was just completed (not already complete)
            const otherLessonsWereComplete = lessons.filter(id => id !== State.currentLesson.id).every(id => State.progress[id]?.done);
            if (otherLessonsWereComplete) {
                return moduleNum;
            }
        }
    }
    return null;
}

function showSuccessAnimation() {
    // Create confetti effect
    const colors = ['#49f7c2', '#7ea8ff', '#4df3a3', '#ffd36e'];
    for (let i = 0; i < 15; i++) {
        setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.style.cssText = `
                position: fixed;
                top: 20%;
                left: ${Math.random() * 100}%;
                width: 10px;
                height: 10px;
                background: ${colors[Math.floor(Math.random() * colors.length)]};
                z-index: 10000;
                animation: fall 2s linear forwards;
                border-radius: 50%;
            `;
            document.body.appendChild(confetti);
            
            setTimeout(() => confetti.remove(), 2000);
        }, i * 100);
    }
}

// Add CSS for falling animation
if (!document.querySelector('#confetti-style')) {
    const style = document.createElement('style');
    style.id = 'confetti-style';
    style.textContent = `
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
    `;
    document.head.appendChild(style);
}

// Lesson Management
function loadLesson(id) {
    const lesson = Lessons[id];
    if (!lesson) return;
    State.currentLesson = lesson; State.ipIndex = 0; resetRegisters();
    if (lesson.disasm[0]) State.regs.rip = BigInt(lesson.disasm[0].a);
    
    // Reset breakpoints for new lesson
    State.breakpoints = [];
    State.hits = [];
    
    renderAll(); 
    switchTab('lesson'); // Auto-switch to lesson tab
}

// Rendering
function renderAll() { 
    renderDisasm(); 
    renderRegisters(); 
    renderFlags(); 
    renderStrings();
    renderHex();
    renderCFG();
    renderLessonStatus(); 
}

function renderCFG() {
    const svg = document.getElementById('cfg-svg');
    const lesson = State.currentLesson;
    
    if (!lesson) {
        svg.innerHTML = `
            <text x="400" y="200" text-anchor="middle" fill="var(--muted)" font-size="14">
                No lesson loaded
            </text>`;
        return;
    }
    
    if (!lesson.cfg) {
    if (!lesson.cfg) {
        // Generate a simple linear CFG for lessons without explicit CFG
        svg.innerHTML = `
            <defs>
                <filter id="glow">
                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                    <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                    </feMerge>
                </filter>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#3a4757" />
                </marker>
            </defs>
            <rect x="100" y="60" width="400" height="280" rx="12" fill="var(--panel)" stroke="var(--accent)" stroke-width="2" stroke-dasharray="5,5"/>
            <text x="300" y="100" text-anchor="middle" fill="var(--neon)" font-size="16" font-weight="bold">${lesson.title}</text>
            <text x="300" y="130" text-anchor="middle" fill="var(--ink)" font-size="14">${lesson.disasm.length} instructions</text>
            <text x="300" y="160" text-anchor="middle" fill="var(--muted)" font-size="12">Sequential Execution Flow</text>
            
            <g transform="translate(150, 190)">
                <rect x="0" y="0" width="300" height="80" rx="8" fill="rgba(126, 168, 255, 0.1)" stroke="var(--accent)" stroke-width="1"/>
                <text x="150" y="30" text-anchor="middle" fill="#7ea8ff" font-size="14" font-weight="bold">Linear Flow</text>
                <text x="150" y="50" text-anchor="middle" fill="var(--ink)" font-size="12">Instructions execute in order</text>
                <text x="150" y="65" text-anchor="middle" fill="var(--muted)" font-size="11">No branches or loops</text>
            </g>
            
            <g class="cfg-node ${State.ipIndex >= 0 ? 'active' : ''}" transform="translate(250, 300)">
                <circle cx="0" cy="0" r="20" fill="var(--neon)" opacity="0.8"/>
                <text x="0" y="5" text-anchor="middle" fill="var(--bg)" font-size="12" font-weight="bold">RIP</text>
            </g>
            
            <text x="300" y="350" text-anchor="middle" fill="var(--muted)" font-size="11">üí° Select lessons with branches/loops for detailed CFG</text>`;
        return;
    }
    
    const NS = 'http://www.w3.org/2000/svg';
    svg.innerHTML = '';
    
    // Add defs back after clearing
    const defs = document.createElementNS(NS, 'defs');
    defs.innerHTML = `
        <filter id="glow">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
                <feMergeNode in="coloredBlur"/>
                <feMergeNode in="SourceGraphic"/>
            </feMerge>
        </filter>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#3a4757" />
        </marker>
        <marker id="arrowhead-active" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#49f7c2" />
        </marker>`;
    svg.appendChild(defs);
    
    const cfg = lesson.cfg;
    const currentInstr = lesson.disasm[State.ipIndex];
    
    // Draw edges first (so they appear behind nodes)
    cfg.edges.forEach(edge => {
        const fromBlock = cfg.blocks.find(b => b.id === edge.from);
        const toBlock = cfg.blocks.find(b => b.id === edge.to);
        
        if (!fromBlock || !toBlock) return;
        
        const path = document.createElementNS(NS, 'path');
        
        let fromX, fromY, toX, toY;
        
        if (edge.from === edge.to) {
            // Self-loop
            fromX = fromBlock.x + fromBlock.width;
            fromY = fromBlock.y + fromBlock.height / 2;
            toX = fromBlock.x + fromBlock.width;
            toY = fromBlock.y;
            path.setAttribute('d', `M ${fromX} ${fromY} Q ${fromX + 40} ${fromY - 40} ${toX} ${toY}`);
        } else {
            // Regular edge with curved lines for better visualization
            fromX = fromBlock.x + fromBlock.width / 2;
            fromY = fromBlock.y + fromBlock.height;
            toX = toBlock.x + toBlock.width / 2;
            toY = toBlock.y;
            
            // Calculate control points for curved lines
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            const ctrlX = midX;
            const ctrlY = midY - 30;
            
            path.setAttribute('d', `M ${fromX} ${fromY} Q ${ctrlX} ${ctrlY} ${toX} ${toY}`);
        }
        
        path.setAttribute('class', `cfg-edge ${edge.type}`);
        path.setAttribute('marker-end', 'url(#arrowhead)');
        
        // Add label if exists
        if (edge.label) {
            const text = document.createElementNS(NS, 'text');
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2 - 10;
            text.setAttribute('x', midX);
            text.setAttribute('y', midY);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('fill', '#8aa2b2');
            text.setAttribute('font-size', '10');
            text.textContent = edge.label;
            svg.appendChild(text);
        }
        
        svg.appendChild(path);
    });
    
    // Draw nodes with improved styling
    cfg.blocks.forEach(block => {
        const group = document.createElementNS(NS, 'g');
        group.setAttribute('class', 'cfg-node');
        group.setAttribute('data-block-id', block.id);
        
        // Check if this block contains the current instruction
        const isActive = currentInstr && block.instrs.includes(State.ipIndex);
        if (isActive) {
            group.classList.add('active');
        }
        
        // Rectangle with improved styling
        const rect = document.createElementNS(NS, 'rect');
        rect.setAttribute('x', block.x);
        rect.setAttribute('y', block.y);
        rect.setAttribute('width', block.width);
        rect.setAttribute('height', block.height);
        rect.setAttribute('rx', '8'); // More rounded corners
        rect.setAttribute('ry', '8');
        group.appendChild(rect);
        
        // Block header
        const headerRect = document.createElementNS(NS, 'rect');
        headerRect.setAttribute('x', block.x);
        headerRect.setAttribute('y', block.y);
        headerRect.setAttribute('width', block.width);
        headerRect.setAttribute('height', '20');
        headerRect.setAttribute('rx', '8');
        headerRect.setAttribute('ry', '8');
        headerRect.setAttribute('fill', 'rgba(126, 168, 255, 0.1)');
        group.appendChild(headerRect);
        
        // Block ID label
        const blockIdText = document.createElementNS(NS, 'text');
        blockIdText.setAttribute('x', block.x + block.width / 2);
        blockIdText.setAttribute('y', block.y + 15);
        blockIdText.setAttribute('text-anchor', 'middle');
        blockIdText.setAttribute('font-weight', 'bold');
        blockIdText.setAttribute('fill', '#7ea8ff');
        blockIdText.setAttribute('font-size', '12');
        blockIdText.textContent = block.id;
        group.appendChild(blockIdText);
        
        // Text with improved formatting
        const lines = block.label.split('\n');
        lines.forEach((line, i) => {
            const text = document.createElementNS(NS, 'text');
            text.setAttribute('x', block.x + 10);
            text.setAttribute('y', block.y + 35 + i * 16);
            text.setAttribute('fill', '#e6f1ff');
            text.setAttribute('font-family', 'var(--mono)');
            text.setAttribute('font-size', '12');
            text.textContent = line;
            group.appendChild(text);
        });
        
        // Add instruction count
        if (block.instrs.length > 0) {
            const countText = document.createElementNS(NS, 'text');
            countText.setAttribute('x', block.x + block.width - 10);
            countText.setAttribute('y', block.y + block.height - 10);
            countText.setAttribute('text-anchor', 'end');
            countText.setAttribute('fill', '#8aa2b2');
            countText.setAttribute('font-size', '10');
            countText.textContent = `${block.instrs.length} instr${block.instrs.length > 1 ? 's' : ''}`;
            group.appendChild(countText);
        }
        
        // Click handler
        group.addEventListener('click', () => {
            if (block.instrs.length > 0) {
                // Jump to first instruction in block
                State.ipIndex = block.instrs[0];
                const instr = lesson.disasm[State.ipIndex];
                if (instr) {
                    State.regs.rip = BigInt(instr.a);
                    renderAll();
                    print(`Jumped to block ${block.id} at ${hex(instr.a)}`);
                }
            }
        });
        
        svg.appendChild(group);
    });
}

function renderStrings() {
    const container = document.getElementById('strings-content');
    if (!State.currentLesson || !State.currentLesson.strings) {
        container.innerHTML = '<div>Found strings:</div><div style="margin-top: 10px; color: var(--muted);">No strings found</div>';
        return;
    }
    
    let html = '<div><strong>Found strings:</strong></div>';
    State.currentLesson.strings.forEach((str, i) => {
        html += `<div style="margin: 8px 0; padding: 6px 12px; background: rgba(255,255,255,0.02); border-radius: 4px; font-family: var(--mono);">
            <span style="color: var(--accent);">[${i}]</span> 
            <span style="color: var(--ink);">"${esc(str)}"</span>
            <span style="color: var(--muted); font-size: 11px;"> (length: ${str.length})</span>
        </div>`;
    });
    container.innerHTML = html;
}

function renderHex() {
    const container = document.getElementById('hex-content');
    if (!State.currentLesson) {
        container.innerHTML = '<div style="color: var(--muted);">No lesson loaded</div>';
        return;
    }
    
    const lesson = State.currentLesson;
    let html = '';
    
    // Generate hex view from disassembly
    let addr = lesson.base;
    let hexData = '';
    let asciiData = '';
    let byteCount = 0;
    
    lesson.disasm.forEach((instr, i) => {
        const bytes = instr.b.replace(/\s+/g, ' ').split(' ');
        bytes.forEach(byte => {
            if (byte.length === 2) {
                hexData += byte + ' ';
                const ascii = parseInt(byte, 16);
                asciiData += (ascii >= 32 && ascii <= 126) ? String.fromCharCode(ascii) : '.';
                byteCount++;
                
                if (byteCount % 8 === 0) hexData += ' ';
                
                if (byteCount % 16 === 0) {
                    html += `<div class="hex-row ${State.ipIndex === i ? 'current' : ''}">
                        <div style="color: var(--accent);">${hex(addr).substring(2).toUpperCase()}</div>
                        <div style="font-family: var(--mono);">${hexData.trim()}</div>
                        <div style="color: var(--muted);">${asciiData}</div>
                    </div>`;
                    addr += 16;
                    hexData = '';
                    asciiData = '';
                    byteCount = 0;
                }
            }
        });
    });
    
    // Add remaining bytes if any
    if (byteCount > 0) {
        // Pad with spaces to align properly
        while (byteCount < 16) {
            hexData += '   ';
            if (byteCount % 8 === 0) hexData += ' ';
            asciiData += ' ';
            byteCount++;
        }
        
        html += `<div class="hex-row">
            <div style="color: var(--accent);">${hex(addr).substring(2).toUpperCase()}</div>
            <div style="font-family: var(--mono);">${hexData.trim()}</div>
            <div style="color: var(--muted);">${asciiData}</div>
        </div>`;
    }
}

    
    if (!html) {
        html = '<div style="color: var(--muted);">No hex data available</div>';
    }
    
    container.innerHTML = html;
}

function renderDisasm() {
    if (!State.currentLesson) return;
    const container = document.getElementById('disasm-view');
    container.innerHTML = '';
    State.currentLesson.disasm.forEach((instr, i) => {
        const row = document.createElement('div');
        row.className = 'disasm-row';
        if (State.ipIndex === i) row.classList.add('is-ip');
        
        // Check for breakpoints
        const addr = instr.a;
        if (State.breakpoints.includes(addr)) {
            row.classList.add('is-bp');
        }
        
        row.innerHTML = `<div class="addr">${hex(instr.a)}</div><div class="bytes">${instr.b}</div><div>${esc(instr.s)}</div>`;
        
        // Click to toggle breakpoint
        row.addEventListener('click', () => {
            const address = instr.a;
            const bpIndex = State.breakpoints.indexOf(address);
            if (bpIndex === -1) {
                State.breakpoints.push(address);
                print(`Breakpoint set at ${hex(address)}`);
            } else {
                State.breakpoints.splice(bpIndex, 1);
                print(`Breakpoint removed from ${hex(address)}`);
            }
            renderDisasm();
        });
        
        container.appendChild(row);
    });
}

function renderRegisters() {
    const items = document.querySelectorAll('.reg-item');
    const regNames = ['rax', 'rbx', 'rcx', 'rdx', 'rsi', 'rdi', 'rbp', 'rsp', 'rip'];
    items.forEach((item, i) => {
        const regName = regNames[i];
        const value = State.regs[regName];
        const valueEl = item.querySelector('.value');
        const oldValue = valueEl.textContent;
        const newValue = hex(value);
        valueEl.textContent = newValue;
        if (oldValue !== newValue && oldValue !== '0x0000000000000000') {
            item.classList.add('flash');
            setTimeout(() => item.classList.remove('flash'), 800);
        }
    });
}

function renderFlags() {
    const flags = document.querySelectorAll('.flag');
    const flagNames = ['zf', 'sf', 'of', 'cf'];
    flags.forEach((flag, i) => {
        const flagName = flagNames[i];
        const isOn = State.flags[flagName];
        flag.classList.toggle('on', isOn);
    });
}
function renderLessonStatus() {
    const rightCard = document.getElementById('lesson-status');
    const centerContent = document.getElementById('lesson-content');
    
    if (!State.currentLesson) {
        rightCard.innerHTML = '<h4>Debugger Panel</h4><p>No lesson loaded</p>';
        centerContent.innerHTML = `
            <div class="lesson-card">
                <h4>Welcome to Hacker Lab!</h4>
                <p>Select a lesson from the left sidebar to begin your journey.</p>
                <div style="margin-top: 20px; padding: 15px; background: rgba(73,247,194,0.05); border-radius: 8px; border-left: 3px solid var(--neon);">
                    <strong>üéØ How it works:</strong><br>
                    ‚Ä¢ Choose a lesson from the left sidebar<br>
                    ‚Ä¢ Read the detailed explanation in this tab<br>
                    ‚Ä¢ Use the debugger tools on the right to practice<br>
                    ‚Ä¢ Step through code with F10 or 'si' command<br>
                    ‚Ä¢ Check your progress with the 'check' command
                </div>
            </div>`;
        return;
    }
    
    const lesson = State.currentLesson;
    const completed = State.progress[lesson.id]?.done ? '‚úÖ' : '';
    
    // Render lesson content in center
    const explanation = lesson.explanation ? `
        <div style="background: rgba(73,247,194,0.05); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 3px solid var(--neon); line-height: 1.6;">
            <strong>üí° What's happening:</strong><br>
            ${lesson.explanation.replace(/\n/g, '<br>')}
        </div>` : '';
    
    const currentStep = State.ipIndex < lesson.trace?.length ? lesson.trace[State.ipIndex] : null;
    const stepNote = currentStep?.note ? `
        <div style="background: rgba(126,168,255,0.05); padding: 12px; border-radius: 6px; margin: 10px 0; border-left: 3px solid var(--accent);">
            <strong>üìù Current Step:</strong> ${currentStep.note}
        </div>` : '';
    
    centerContent.innerHTML = `
        <div class="lesson-card">
            <h2>${lesson.title} ${completed}</h2>
            <div style="margin: 15px 0; padding: 12px; background: rgba(255,211,110,0.1); border-radius: 6px; border-left: 3px solid var(--warn);">
                <strong>üéØ Goal:</strong> ${lesson.goal}
            </div>
            <div style="margin: 15px 0; padding: 12px; background: rgba(126,168,255,0.05); border-radius: 6px; border-left: 3px solid var(--accent);">
                <strong>üí´ Hint:</strong> ${lesson.hint}
            </div>
            ${explanation}
            ${stepNote}
            <div style="margin-top: 20px; padding: 15px; background: rgba(255,255,255,0.02); border-radius: 8px;">
                <strong>üéÆ Interactive Commands:</strong><br>
                ‚Ä¢ <code>si</code> or F10 - Step through instructions<br>
                ‚Ä¢ <code>c</code> or F9 - Continue execution<br>
                ‚Ä¢ <code>break 0xADDR</code> - Set breakpoint<br>
                ‚Ä¢ <code>flow</code> - View control flow graph<br>
                ‚Ä¢ <code>check</code> - Check if goal is achieved
            </div>
        </div>
    `;
    
    // Render interactive debugger panel on the right
    rightCard.innerHTML = `
        <h4>üõ†Ô∏è Debugger Control</h4>
        <div style="margin: 12px 0;">
            <button class="btn" onclick="runCmd('si')">‚û°Ô∏è Step (F10)</button>
            <button class="btn" onclick="runCmd('c')">‚ñ∂Ô∏è Continue (F9)</button>
        </div>
        <div style="margin: 12px 0;">
            <button class="btn" onclick="runCmd('flow')">üîÄ Flow Graph</button>
            <button class="btn success" onclick="runCmd('check')">‚úÖ Check Goal</button>
        </div>
        <div style="margin: 12px 0;">
            <button class="btn" onclick="runCmd('reset')">üîÑ Reset</button>
            <button class="btn" onclick="runCmd('bps')">üî¥ Breakpoints</button>
        </div>
        <div style="margin-top: 15px; padding: 10px; background: rgba(255,255,255,0.02); border-radius: 6px; font-size: 11px;">
            <strong>üìä Status:</strong><br>
            Step: ${State.ipIndex}/${lesson.trace?.length - 1 || 0}<br>
            Breakpoints: ${State.breakpoints.length}<br>
            Progress: ${completed ? 'Complete' : 'In Progress'}
        </div>
    `;
}

function updateLessonProgress() {
    // Clear all active states first
    document.querySelectorAll('.lesson-item').forEach(item => {
        item.classList.remove('completed', 'active');
    });
    
    // Mark completed lessons
    Object.keys(Lessons).forEach(id => {
        const item = document.querySelector(`[data-lesson="${id}"]`);
        if (item && State.progress[id]?.done) {
            item.classList.add('completed');
        }
    });
    
    // Mark currently active lesson
    if (State.currentLesson) {
        const activeItem = document.querySelector(`[data-lesson="${State.currentLesson.id}"]`);
        if (activeItem) {
            activeItem.classList.add('active');
        }
    }
    
    // Update progress statistics
    updateProgressStats();
}

function updateProgressStats() {
    const totalLessons = Object.keys(Lessons).length;
    const completedLessons = Object.values(State.progress).filter(p => p.done).length;
    const progressPercent = Math.round((completedLessons / totalLessons) * 100);
    const span = document.getElementById('progress-span');
    if (span) span.textContent = `Progress: ${completedLessons}/${totalLessons} (${progressPercent}%)`;
}

// UI Event Handlers
function switchTab(tabName) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    document.querySelectorAll('.view-content > div').forEach(v => v.classList.add('hidden'));
    document.getElementById(`${tabName}-view`).classList.remove('hidden');
    State.activeTab = tabName;
}

function exportProgress() {
    const data = { progress: State.progress, timestamp: Date.now() };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'hacker_lab_progress.json'; a.click();
    URL.revokeObjectURL(url);
}

// Event Listeners
document.addEventListener('DOMContentLoaded', () => {
    State.progress = loadProgress(); updateLessonProgress(); renderAll();
    
    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
    });
    
    // Lesson selection
    document.querySelectorAll('.lesson-item').forEach(item => {
        item.addEventListener('click', () => {
            const id = item.dataset.lesson;
            runCmd(`load ${id}`);
        });
    });
    
    // Terminal input with history support
    const termInput = document.getElementById('term-input');
    termInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            const cmd = termInput.value.trim();
            if (cmd) runCmd(cmd);
            termInput.value = '';
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            if (State.commandHistory.length > 0) {
                if (State.historyIndex === -1) {
                    State.historyIndex = State.commandHistory.length - 1;
                } else if (State.historyIndex > 0) {
                    State.historyIndex--;
                }
                termInput.value = State.commandHistory[State.historyIndex] || '';
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            if (State.historyIndex !== -1) {
                State.historyIndex++;
                if (State.historyIndex >= State.commandHistory.length) {
                    State.historyIndex = -1;
                    termInput.value = '';
                } else {
                    termInput.value = State.commandHistory[State.historyIndex] || '';
                }
            }
        }
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.key === 'F10') { e.preventDefault(); runCmd('si'); }
        else if (e.key === 'F9') { e.preventDefault(); runCmd('c'); }
        else if (e.key === '/' && e.target.tagName !== 'INPUT') { 
            e.preventDefault(); termInput.focus(); 
        }
    });
});

// Auto-load first lesson and show welcome
setTimeout(() => {
    if (!State.currentLesson) {
        print('üöÄ Welcome to L0W-L3V3L Lab v2.0 - Interactive Assembly & Reverse Engineering!');
        print('');
        print('üéÜ Features:');
        print('  ‚Ä¢ 13 progressive lessons from beginner to advanced');
        print('  ‚Ä¢ Interactive debugger with pwndbg-style commands');
        print('  ‚Ä¢ Control Flow Graph visualization');
        print('  ‚Ä¢ Real-time register, stack, and flag monitoring');
        print('  ‚Ä¢ Safe sandbox environment - no real code execution');
        print('  ‚Ä¢ ü§ñ Qoder: Custom lesson generator with 4 templates');
        print('');
        print('üéÆ Getting Started:');
        print('  ‚Ä¢ Type "levels" to see all available lessons');
        print('  ‚Ä¢ Type "load 0.1" to start with the first lesson');
        print('  ‚Ä¢ Type "help" for complete command reference');
        print('  ‚Ä¢ Use F10 to step, F9 to continue, "/" to focus terminal');
        print('  ‚Ä¢ Click ü§ñ Qoder button to create custom lessons');
        print('');
        print('Loading first lesson automatically...');
        
        // Initialize Qoder system
        qoderInitUI();
        loadCustomLessonsFromLS();
        setTimeout(() => runCmd('load 0.1'), 1000);
    }
}, 500);
</script>
</body>
</html>